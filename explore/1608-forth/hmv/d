\ load development code
\ needs l

reset

: blink ( -- )  \ blink the on-board LED until a key is pressed
  OMODE-PP LED1 io-mode!  begin  LED1 iox!  100 ms  key? until ;

: tftry tft-init clear TFT-BL ios! demo ;

: pwmtry ( -- )  1 LED2 +pwm 100 LED2 pwm ;

\ -----------------------------------------------------------------------------

: sleep ( -- ) [ $BF30 h, ] inline ;  \ WFI Opcode, enters sleep mode

      PWR $4 + constant PWR-CSR

$E000ED00 constant SCB
     SCB $14 + constant SCB-SCR

: standby ( -- )  \ go into low-power standby mode
  2 bit PWR-CR bis!  \ CWUF
  1 bit PWR-CR bis!  \ PDDS
  2 bit SCB-SCR bis!  \ SLEEPDEEP
  sleep ;

\ TODO not working, not even with OMODE-AF-OD PA0 io-mode!
: ena-wup ( -- )  \ enable wakeup pin
  8 bit PWR-CSR bis! ;

\ -----------------------------------------------------------------------------

: sd>slow> ( c -- c )  \ bit-banged SPI, 8 bits, well under 400 KHz
  8 0 do
    dup $80 and MOSI io!
    2 us  SCLK ios!  2 us
    shl
    MISO io@ or
    2 us  SCLK ioc!  2 us
  loop
  $FF and ;

: sd-slow ( u -- )
  -spi 2 us +spi 2 us
  dup 24 rshift dup $3F and [char] # emit . sd>slow> drop
              0 sd>slow> drop
              0 sd>slow> drop
  dup 16 rshift sd>slow> drop
   dup 8 rshift sd>slow> drop
                sd>slow> drop
            $FF sd>slow> drop
            $FF sd>slow> . ;

: sd-init ( -- )
  spi-init
  10 0 do $FF sd>slow> drop loop
  +spi
  $40000095 sd-slow  \ CMD0 go idle
\ $41000000 sd-slow  \ CMD1 send op cond
\ $50020000 sd-slow  \ CMD16 send blocklen 512
\ $7B000000 sd-slow  \ CMD59 crc off
\ $4801AA87 sd-slow  \ CMD8 send if cond 3.3v
  $77000000 sd-slow  $69000000 sd-slow  \ ACMD41 send op cond
  200 ms
  $77000000 sd-slow  $69000000 sd-slow  \ ACMD41 send op cond
;

: sd-cmd ( cmd arg -- )
  swap dup $80 and if  $77 0 recurse  $7F and  then
  -spi +spi
  begin $FF >spi> $FF = until
  cr dup $3F and .
                >spi
  dup 24 rshift >spi
  dup 16 rshift >spi
   dup 8 rshift >spi
                >spi
              0 >spi
            $FF >spi
            $FF >spi> . ;

: sd-wait ( -- )
  -1  50 0 do  $FF >spi> $FE = if drop i leave then  loop  . ;

: sd-read ( page addr -- f )  \ read one 512-byte page from sdcard
  $51 rot 9 lshift sd-cmd sd-wait
  512 0 do  $FF >spi> over i + c!  loop
  drop true ;  \ TODO return actual success flag

$20008000 constant sdbuf  \ page aligned, for nicer dump

: s $FF >spi> h.2 space ;

: c ( char -- )
  dup $FF = if drop else
    dup 32 < over 126 > or if drop [char] . then emit
  then ;
: e ( off1 off2 -- off1 )
  over + sdbuf + c@ c ;
: l ( off -- )
  1 e 3 e 5 e 7 e 9 e
  14 e 16 e 18 e 20 e 22 e 24 e 28 e 30 e
  ."  #" sdbuf + c@ dup $1F and . $40 and . ;
: f ( off -- )
  dup sdbuf + 8 type [char] . emit dup 8 + sdbuf + 3 type
  ."  at: " 26 + sdbuf + h@ .
;

: sdtry
  sd-init
  $CD 0            sd-cmd sd-wait s s s s s s s s s s s s s s s s  \ ACMD13
  $49 0            sd-cmd sd-wait s s s s s s s s s s s s s s s s  \ CMD9
  0 sdbuf sd-read drop  \ read block #0
  sdbuf $1C6 + @ dup hex.  \ extract partition start
  dup sdbuf sd-read drop  \ read boot record
  sdbuf 64 dump
  sdbuf $0B + h@     .  \ bytes per sector
  sdbuf $0D + c@     .  \ sectors per cluster
  sdbuf $0E + h@ dup .  \ reserved sectors
  sdbuf $10 + h@ dup .  \ number of FAT copies
  sdbuf $16 + h@ dup .  \ sectors per fat
  sdbuf $2B + 11 type  [char] : emit  sdbuf $36 + 8 type  \ label & format
  * + + dup .
  sdbuf sd-read drop  \ read 1st block of FAT
  sdbuf 352 dump
  512 0 do
    i sdbuf + c@ dup 0<> swap $E5 <> and if
      i 11 + sdbuf + c@ $0F = if
        cr ." LFN: "  i l
      else
        cr ."      " i f
      then
    then
  32 +loop
;

\ -----------------------------------------------------------------------------
\ vim: set ft=forth :
