\ load development code
\ needs l

reset

: blink ( -- )  \ blink the on-board LED until a key is pressed
  OMODE-PP LED io-mode!
  begin
    LED iox!
    1000000 0 do loop
  key? until ;

: rtctry ( -- )  +i2c  0 0 rtc!  begin  0 rtc@ $FF and .  key? until ;
: adctry ( -- )  +adc  begin  PB0 adc .  key? until ;
: uartry ( -- )  +uart uart. ;

\ -----------------------------------------------------------------------------

$A0000008 constant FSMC-BCR2
$A000000C constant FSMC-BTR2
$A000010C constant FSMC-BWTR2

: psram-pins ( -- )
  8 bit RCC-AHBENR bis!  \ enable FSMC clock

  5 bit RCC-APB2ENR bis!  \ enable GPIOD
  6 bit RCC-APB2ENR bis!  \ enable GPIOE
  7 bit RCC-APB2ENR bis!  \ enable GPIOF
  8 bit RCC-APB2ENR bis!  \ enable GPIOG

  OMODE-AF-PP OMODE-FAST +
  dup PE0  io-mode!  dup PE1  io-mode!  dup PE3  io-mode!  dup PE4  io-mode!
  dup PE5  io-mode!  dup PE6  io-mode!  dup PE7  io-mode!  dup PE8  io-mode!
  dup PE9  io-mode!  dup PE10 io-mode!  dup PE11 io-mode!  dup PE12 io-mode!
  dup PE13 io-mode!  dup PE14 io-mode!  dup PE15 io-mode!  dup PF0  io-mode!
  dup PF1  io-mode!  dup PF2  io-mode!  dup PF3  io-mode!  dup PF4  io-mode!
  dup PF5  io-mode!  dup PF12 io-mode!  dup PF13 io-mode!  dup PF14 io-mode!
  dup PF15 io-mode!  dup PG0  io-mode!  dup PG1  io-mode!  dup PG2  io-mode!
  dup PG3  io-mode!  dup PG4  io-mode!  dup PG5  io-mode!  dup PG9  io-mode!
  dup PD0  io-mode!  dup PD1  io-mode!  dup PD4  io-mode!  dup PD5  io-mode!
  dup PD8  io-mode!  dup PD9  io-mode!  dup PD10 io-mode!  dup PD11 io-mode!
  dup PD12 io-mode!  dup PD13 io-mode!  dup PD14 io-mode!  dup PD15 io-mode!
  drop
;

: psram-fsmc ( -- )
  $80               \ keep reset value
\                   \ FSMC_DataAddressMux_Disable
  %01 2 lshift or   \ FSMC_MemoryType_PSRAM
  %01 4 lshift or   \ FSMC_MemoryDataWidth_16b
\                   \ FSMC_BurstAccessMode_Disable
\                   \ FSMC_WaitSignalPolarity_Low
\                   \ FSMC_WrapMode_Disable
\                   \ FSMC_WaitSignalActive_BeforeWaitState
  1 12 lshift or    \ FSMC_WriteOperation_Enable
\                   \ FSMC_WaitSignal_Disable
\                   \ FSMC_AsynchronousWait_Disable
\                   \ FSMC_ExtendedMode_Disable
\                   \ FSMC_WriteBurst_Disable
  FSMC-BCR2 !

\ for 72 MHz, i.e. 13.89 ns per clock cycle
\ assuming address setup > 70 ns and data setup > 20 ns + 1 cycle
\ started with addr/data/turn as 5/2/1, but even 1/1/0 seems to work fine...

  0
  1 0 lshift or     \ FSMC_AddressSetupTime = 6
\                   \ FSMC_AddressHoldTime = 0
  1 8 lshift or     \ FSMC_DataSetupTime = 3
  0 16 lshift or    \ FSMC_BusTurnAroundDuration = 2
\                   \ FSMC_CLKDivision = 0x00
\                   \ FSMC_DataLatency = 0x00
\                   \ FSMC_AccessMode_A
  FSMC-BTR2 !

  $0FF00000         \ keep reset value
  1 0 lshift or     \ FSMC_AddressSetupTime = 6
\                   \ FSMC_AddressHoldTime = 0
  1 8 lshift or     \ FSMC_DataSetupTime = 3
  0 16 lshift or    \ FSMC_BusTurnAroundDuration = 2
\                   \ FSMC_CLKDivision = 0x00
\                   \ FSMC_DataLatency = 0x00
\                   \ FSMC_AccessMode_A
  FSMC-BWTR2 !

  1 FSMC-BCR2 bis!  \ MBKEN:Memorybankenablebit
;

$64000000 constant PSRAM

: psram-init ( -- )  \ set up FSMC access to 8 MB PSRAM in bank 2
  psram-pins psram-fsmc ;

\ see http://compgroups.net/comp.lang.forth/random-number-generator/1259025
\ only last bit should be used, but for this purpose we can use all 32 bits

123456789 variable seed

: random ( -- u ) seed @ dup ror or seed @ rol xor dup seed ! ;

: r 0 do random hex. loop ;

: psram-test ( u -- )  \ test first N bytes of PSRAM, original data is lost
  psram-init
  $12345678 seed !
  dup 0 do
    random PSRAM i + !  \ fill it with random values
  4 +loop
  PSRAM $40 dump
  $12345678 seed !
  0 do
    random PSRAM i + @  \ now read those values back and compare
    <> if i . ." FAILED!" quit then
  4 +loop ;

: psram-full ( -- )  \ test all of PSRAM, then clear its contents
  23 bit  dup psram-test  PSRAM swap 0 fill ;

: psram-time ( -- )  \ measure read and write times for a full scan
  psram-init
  micros  23 bit 0 do                      4 +loop  micros swap - .
  micros  23 bit 0 do  i             drop  4 +loop  micros swap - .
  micros  23 bit 0 do    PSRAM i + @ drop  4 +loop  micros swap - .
  micros  23 bit 0 do  i PSRAM i + !       4 +loop  micros swap - . ;
\ sample output: 495471 641201 1486421 1369795

\ -----------------------------------------------------------------------------

\ vim: set ft=forth :
