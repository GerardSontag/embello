\ load development code
\ needs l

reset
led io-1!

: usb-clear ( -- )
  1024 0 do  0 i USBMEM + h!  4 +loop ;

: usb-reset ( -- )
\  5432109876543210
  %1011001010010000 USB-EP0R h!  \ ctrl rx-val tx-stall
  %1000000010100001 USB-EP1R h!  \ bulk rx-dis tx-nak
  %1000011010100010 USB-EP2R h!  \ intr rx-dis tx-nak
  %1011000010000011 USB-EP3R h!  \ bulk rx-val tx-dis
  $80 USB-DADDR h! ;

: set-txstat ( u -- )  \ awful code, avoids toggling/setting any other fields
  4 lshift  USB-EP0R h@ tuck  xor
\  5432109876543210
  %0000000000110000 and swap
  %0000011100001111 and
  %1000000010000000 or
  or USB-EP0R h! ;

: send-desc ( addr -- )  \ see definitions of usb:1 etc
  dup c@ 0 do
    dup i + h@  i $80 + shl USBMEM + h!
  2 +loop
  c@ USBMEM 4 + h!  \ COUNT0_TX
  %11 set-txstat ;

: +usb ( -- )  \ init USB hardware
  OMODE-PP PA0 io-mode!  PA0 io-1!  \ usb-off HyTiny
  OMODE-AF-PP OMODE-FAST + PA11 io-mode!  \ hw_config.c:115
  OMODE-AF-PP OMODE-FAST + PA12 io-mode!
  23 bit RCC-APB1ENR bis!  \ USBEN hw_config.c:162
  $0003 USB-CNTR h!
  10 0 do loop
  $0001 USB-CNTR h!  \ usb_pwr.c:73
  10 0 do loop
  usb-clear
  $0000 USB-CNTR h!  \ usb_pwr.c:77
  usb-init
  0 USB-ISTR h!  \ clear all pending interrupts
  usb-reset
  $1C00 USB-CNTR h!  \ usb_pwr.c:82
  PA0 io-0!  \ usb-on HyTiny
;

: -usb ( -- )  \ deinit USB hardware
  23 bit RCC-APB1ENR bic!  \ USBEN
  PA0 io-1!  \ usb-off HyTiny
  $0001 USB-CNTR h! ;

0 variable last

: usb-poll ( -- )
  USB-ISTR h@  dup last @ <> if
    dup last !  dup h.4 space  dup if dup istr. cr then
  then
  dup $400 and if  \ reset
    ." RESET!"
    usb-init usb-reset
    usb. cr cr
  then
  $200 and if  \ sof
    ." SOF!"
    usb.mem cr
    usb:dev send-desc
  then
  0 USB-ISTR h!  \ clear all pending interrupts
;

: try +usb  usb. \ usb.mem
\ 5 0 do  cr cr 100000 0 do usb-poll loop  cr usb.  loop
\ 1 0 do  cr cr 10000 0 do usb-poll loop  cr usb.  loop
  cr cr
  1000000 0 do usb-poll loop
  cr usb.mem cr usb. -usb ;

try

\ vim: set ft=forth :
