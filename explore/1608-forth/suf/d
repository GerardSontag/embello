\ load development code
\ needs l

reset
led ios!

false variable debug
: +d true debug ! ;
: -d false debug ! ;
: d? debug @ ;

\ -----------------------------------------------------------------------------

0 variable zero

128 4 + buffer: usb-in-ring
 64 4 + buffer: usb-out-ring

\ -----------------------------------------------------------------------------
( code-start, see code-size below ) here

: usb-init-rings ( -- )
  usb-in-ring 128 init-ring
  usb-out-ring 64 init-ring ;

: ep-setup ( ep -- )  \ setup packets, sent from host to config this device
  dup rxclear
\ d? if cr ." setup: " $48 $40 do i usb-pma@ h.4 space 2 +loop then
  $41 usb-pma c@ case
    $00 of zero 2 send-data endof
    $06 of send-desc endof
\   $20 of usb:line 7 send-data endof
\   $22 is baud rate?
\   $23 is break?
    true ?of 0 0 send-data endof
  endcase
  ep-reset-rx# send-next
;

: usb-recv ( c -- ) usb-in-ring dup ring? if >ring else 2drop then ;

0 variable tx.pend

: usb-pma-c! ( b pos -- )  \ careful, can't write high bytes separately
  dup 1 and if
    1- dup usb-pma@ rot 8 lshift or swap
  then usb-pma! ;

: usb-fill ( -- )
  tx.pend @ 0= if
    usb-out-ring ring#
    ?dup if 64 min
      dup tx.pend !
      dup 0 do usb-out-ring ring> $C0 i + usb-pma-c!  loop
      1 1 ep-reg h! 1 3 txstat!
    then
  then ;

: ep-out ( ep -- )  \ outgoing packets, sent from host to this device
  dup rxclear
  dup if  \ only pick up data for endpoint 3
    dup 3 ep-reg h@ $3F and 0 ?do
      i $100 + usb-pma c@ usb-recv
    loop
  then
  ep-reset-rx#
;

: ep-in ( ep -- )  \ incoming polls, sent from this device to host
\ d? if [char] I emit dup . then
  dup if
    0 tx.pend ! usb-fill
  else
    $41 usb-pma c@ $05 = if $42 usb-pma@ $80 or USB-DADDR h! then
    send-next
  then
  txclear
;

: usb-ctr ( istr -- )
  dup $07 and swap $10 and if 
    dup ep-addr h@ $800 and if ep-setup else ep-out then
  else ep-in then ;

: usb-poll
  USB-ISTR h@
  dup $8000 and if dup usb-ctr          $7FFF USB-ISTR h! then
  dup $0400 and if usb-reset            $FBFF USB-ISTR h! then
  dup $0800 and if %1100 USB-CNTR hbis! $F7FF USB-ISTR h! then
      $1000 and if %1000 USB-CNTR hbic! $EFFF USB-ISTR h! then ;

: usb-key? ( -- f )  usb-poll usb-in-ring ring# 0<> ;
: usb-key ( -- c )  begin usb-key? until  usb-in-ring ring> ;
: usb-emit? ( -- f )  usb-poll usb-out-ring ring? ;
: usb-emit ( c -- )  begin usb-emit? until  usb-out-ring >ring usb-fill ;

: +usb-io ( -- )
  usb-init-rings
  ['] usb-key? hook-key? !
  ['] usb-key hook-key !
\ ['] usb-emit? hook-emit? !
\ ['] usb-emit hook-emit !
;

: t3 cr +usb +usb-io ;
: t4 ['] usb-emit? hook-emit? ! ['] usb-emit hook-emit ! ;
: t5 t3 1000000 0 do usb-poll loop t4 ;

( code-size ) here swap - .
\ -----------------------------------------------------------------------------

: -usb-io ( -- )
  ['] serial-key? hook-key? !
  ['] serial-key hook-key !
  ['] serial-emit? hook-emit? !
  ['] serial-emit hook-emit !
\ d? if usb-in-ring ring# . usb-out-ring ring# . then
;

\ -----------------------------------------------------------------------------
\ in-memory output buffering

5000 buffer: outbuf
0 variable outpos

: buf-emit? true ;
: buf-emit outpos @ dup 5000 < if outbuf + c!  1 outpos +!  else drop then ;

: save-to-buf
  ['] buf-emit? hook-emit? !
  ['] buf-emit hook-emit !
  0 outpos ! ;
: restore-buf
  ['] serial-emit? hook-emit? !
  ['] serial-emit hook-emit !
  outbuf outpos @ type  0 outpos ! ;

: test-buf save-to-buf ." abc" [char] : serial-emit restore-buf ;

\ -----------------------------------------------------------------------------
\ status and info dumps

: usb. ( -- )  \ dump USB info
  cr ." EP0R " 0 ep-addr h@ h.4
    ."  EP1R " 1 ep-addr h@ h.4
    ."  EP2R " 2 ep-addr h@ h.4
    ."  EP3R " 3 ep-addr h@ h.4
  cr ." CNTR " USB-CNTR h@ h.4
    ."  ISTR " USB-ISTR h@ h.4
     ."  FNR " USB-FNR h@ h.4
   ."  DADDR " USB-DADDR h@ h.4
  ."  BTABLE " USB-BTABLE h@ h.4 ;

: usb.mem ( -- )  \ dump packet buffer memory
  $150 0 do
    i $0F and 0= if cr i h.4 space then
    i $7 and 0= if space then
    i shl USBMEM + h@ h.4 space
  2 +loop ;

\ : try ( -- ) +usb-io begin usb-poll serial-key? until -usb-io ;
\ : t cr +usb try ( usb. usb.mem ) -usb cr cr ;
\ : t2 save-to-buf +usb try d? if usb. usb.mem then -usb restore-buf ;

\ : u1 ( n -- )  \ fill out-bound ring buffer with some test bytes
\   0 do [char] x usb-emit loop [char] / usb-emit usb-out-ring ring# . ;

\ vim: set ft=forth :
