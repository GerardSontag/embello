Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   1
BDOS22  Z80

    1                   ;**************************************************************
    2                   ;*
    3                   ;*             C P / M   version   2 . 2
    4                   ;*
    5                   ;*   Reconstructed from memory image on February 27, 1981
    6                   ;*
    7                   ;*                by Clark A. Calkins
    8                   ;*
    9                   ;**************************************************************
   10                   ;
   11                   ;   Set memory limit here. This is the amount of contigeous
   12                   ; ram starting from 0000. CP/M will reside at the end of this space.
   13                   ;
   14                   
   15         0003      IOBYTE   EQU    3               ;i/o definition byte.
   16         0004      TDRIVE   EQU    4               ;current drive name and user number.
   17         0005      ENTRY    EQU    5               ;entry point for the cp/m bdos.
   18         005C      TFCB     EQU    5CH             ;default file control block.
   19         0080      TBUFF    EQU    80H             ;i/o buffer and command line storage.
   20         0100      TBASE    EQU    100H            ;transiant program storage area.
   21                   ;
   22                   ;   Set control character equates.
   23                   ;
   24         0003      CNTRLC   EQU    3               ;control-c
   25         0005      CNTRLE   EQU    05H             ;control-e
   26         0008      BS       EQU    08H             ;backspace
   27         0009      TAB      EQU    09H             ;tab
   28         000A      LF       EQU    0AH             ;line feed
   29         000C      FF       EQU    0CH             ;form feed
   30         000D      CR       EQU    0DH             ;carriage return
   31         0010      CNTRLP   EQU    10H             ;control-p
   32         0012      CNTRLR   EQU    12H             ;control-r
   33         0013      CNTRLS   EQU    13H             ;control-s
   34         0015      CNTRLU   EQU    15H             ;control-u
   35         0018      CNTRLX   EQU    18H             ;control-x
   36         001A      CNTRLZ   EQU    1AH             ;control-z (end-of-file mark)
   37         007F      DEL      EQU    7FH             ;rubout
   38                   ;
   39                   ;   Set origin for CP/M
   40                   ;
   41         E700               ORG    0E700H
   42                   ;
   43 E700  C3 EA5C     CBASE:  JP      COMMAND         ;execute command processor (ccp).
   44 E703  C3 EA58             JP      CLEARBUF        ;entry to empty input buffer before starting ccp.
   45                   
   46                   ;
   47                   ;   Standard cp/m ccp input buffer. Format is (max length),
   48                   ; (actual length), (char #1), (char #2), (char #3), etc.
   49                   ;
   50 E706  7F          INBUFF:  DB     127             ;length of input buffer.
   51 E707  00                   DB     0               ;current length of contents.
   52 E708  43 6F 70 79          DB     "Copyright"
   53 E711  20 31 39 37          DB     " 1979 (c) by Digital Research      "
   54 E734  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   55 E74B  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   56 E762  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   57 E779  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   58 E788  E708        INPOINT: DW     INBUFF+2        ;input line pointer
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   2
BDOS22  Z80

   59 E78A  0000        NAMEPNT: DW     0               ;input line pointer used for error message. Points to
   60                   ;                       ;start of name in error.
   61                   ;
   62                   ;   Routine to print (A) on the console. All registers used.
   63                   ;
   64 E78C  5F          PRINT:  LD      E,A             ;setup bdos call.
   65 E78D  0E 02               LD      C,2
   66 E78F  C3 0005             JP      ENTRY
   67                   ;
   68                   ;   Routine to print (A) on the console and to save (BC).
   69                   ;
   70 E792  C5          PRINTB: PUSH    BC
   71 E793  CD E78C             CALL    PRINT
   72 E796  C1                  POP     BC
   73 E797  C9                  RET     
   74                   ;
   75                   ;   Routine to send a carriage return, line feed combination
   76                   ; to the console.
   77                   ;
   78 E798  3E 0D       CRLF:   LD      A,CR
   79 E79A  CD E792             CALL    PRINTB
   80 E79D  3E 0A               LD      A,LF
   81 E79F  C3 E792             JP      PRINTB
   82                   ;
   83                   ;   Routine to send one space to the console and save (BC).
   84                   ;
   85 E7A2  3E 20       SPACE:  LD      A,' '
   86 E7A4  C3 E792             JP      PRINTB
   87                   ;
   88                   ;   Routine to print character string pointed to be (BC) on the
   89                   ; console. It must terminate with a null byte.
   90                   ;
   91 E7A7  C5          PLINE:  PUSH    BC
   92 E7A8  CD E798             CALL    CRLF
   93 E7AB  E1                  POP     HL
   94 E7AC  7E          PLINE2: LD      A,(HL)
   95 E7AD  B7                  OR      A
   96 E7AE  C8                  RET     Z
   97 E7AF  23                  INC     HL
   98 E7B0  E5                  PUSH    HL
   99 E7B1  CD E78C             CALL    PRINT
  100 E7B4  E1                  POP     HL
  101 E7B5  C3 E7AC             JP      PLINE2
  102                   ;
  103                   ;   Routine to reset the disk system.
  104                   ;
  105 E7B8  0E 0D       RESDSK: LD      C,13
  106 E7BA  C3 0005             JP      ENTRY
  107                   ;
  108                   ;   Routine to select disk (A).
  109                   ;
  110 E7BD  5F          DSKSEL: LD      E,A
  111 E7BE  0E 0E               LD      C,14
  112 E7C0  C3 0005             JP      ENTRY
  113                   ;
  114                   ;   Routine to call bdos and save the return code. The zero
  115                   ; flag is set on a return of 0ffh.
  116                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   3
BDOS22  Z80

  117 E7C3  CD 0005     ENTRY1: CALL    ENTRY
  118 E7C6  32 EEEE             LD      (RTNCODE),A     ;save return code.
  119 E7C9  3C                  INC     A               ;set zero if 0ffh returned.
  120 E7CA  C9                  RET     
  121                   ;
  122                   ;   Routine to open a file. (DE) must point to the FCB.
  123                   ;
  124 E7CB  0E 0F       OPEN:   LD      C,15
  125 E7CD  C3 E7C3             JP      ENTRY1
  126                   ;
  127                   ;   Routine to open file at (FCB).
  128                   ;
  129 E7D0  AF          OPENFCB:XOR     A               ;clear the record number byte at fcb+32
  130 E7D1  32 EEED             LD      (FCB+32),A
  131 E7D4  11 EECD             LD      DE,FCB
  132 E7D7  C3 E7CB             JP      OPEN
  133                   ;
  134                   ;   Routine to close a file. (DE) points to FCB.
  135                   ;
  136 E7DA  0E 10       CLOSE:  LD      C,16
  137 E7DC  C3 E7C3             JP      ENTRY1
  138                   ;
  139                   ;   Routine to search for the first file with ambigueous name
  140                   ; (DE).
  141                   ;
  142 E7DF  0E 11       SRCHFST:LD      C,17
  143 E7E1  C3 E7C3             JP      ENTRY1
  144                   ;
  145                   ;   Search for the next ambigeous file name.
  146                   ;
  147 E7E4  0E 12       SRCHNXT:LD      C,18
  148 E7E6  C3 E7C3             JP      ENTRY1
  149                   ;
  150                   ;   Search for file at (FCB).
  151                   ;
  152 E7E9  11 EECD     SRCHFCB:LD      DE,FCB
  153 E7EC  C3 E7DF             JP      SRCHFST
  154                   ;
  155                   ;   Routine to delete a file pointed to by (DE).
  156                   ;
  157 E7EF  0E 13       DELETE: LD      C,19
  158 E7F1  C3 0005             JP      ENTRY
  159                   ;
  160                   ;   Routine to call the bdos and set the zero flag if a zero
  161                   ; status is returned.
  162                   ;
  163 E7F4  CD 0005     ENTRY2: CALL    ENTRY
  164 E7F7  B7                  OR      A               ;set zero flag if appropriate.
  165 E7F8  C9                  RET     
  166                   ;
  167                   ;   Routine to read the next record from a sequential file.
  168                   ; (DE) points to the FCB.
  169                   ;
  170 E7F9  0E 14       RDREC:  LD      C,20
  171 E7FB  C3 E7F4             JP      ENTRY2
  172                   ;
  173                   ;   Routine to read file at (FCB).
  174                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   4
BDOS22  Z80

  175 E7FE  11 EECD     READFCB:LD      DE,FCB
  176 E801  C3 E7F9             JP      RDREC
  177                   ;
  178                   ;   Routine to write the next record of a sequential file.
  179                   ; (DE) points to the FCB.
  180                   ;
  181 E804  0E 15       WRTREC: LD      C,21
  182 E806  C3 E7F4             JP      ENTRY2
  183                   ;
  184                   ;   Routine to create the file pointed to by (DE).
  185                   ;
  186 E809  0E 16       CREATE: LD      C,22
  187 E80B  C3 E7C3             JP      ENTRY1
  188                   ;
  189                   ;   Routine to rename the file pointed to by (DE). Note that
  190                   ; the new name starts at (DE+16).
  191                   ;
  192 E80E  0E 17       RENAM:  LD      C,23
  193 E810  C3 0005             JP      ENTRY
  194                   ;
  195                   ;   Get the current user code.
  196                   ;
  197 E813  1E FF       GETUSR: LD      E,0FFH
  198                   ;
  199                   ;   Routne to get or set the current user code.
  200                   ; If (E) is FF then this is a GET, else it is a SET.
  201                   ;
  202 E815  0E 20       GETSETUC: LD    C,32
  203 E817  C3 0005             JP      ENTRY
  204                   ;
  205                   ;   Routine to set the current drive byte at (TDRIVE).
  206                   ;
  207 E81A  CD E813     SETCDRV:CALL    GETUSR          ;get user number
  208 E81D  87                  ADD     A,A             ;and shift into the upper 4 bits.
  209 E81E  87                  ADD     A,A
  210 E81F  87                  ADD     A,A
  211 E820  87                  ADD     A,A
  212 E821  21 EEEF             LD      HL,CDRIVE       ;now add in the current drive number.
  213 E824  B6                  OR      (HL)
  214 E825  32 0004             LD      (TDRIVE),A      ;and save.
  215 E828  C9                  RET     
  216                   ;
  217                   ;   Move currently active drive down to (TDRIVE).
  218                   ;
  219 E829  3A EEEF     MOVECD: LD      A,(CDRIVE)
  220 E82C  32 0004             LD      (TDRIVE),A
  221 E82F  C9                  RET     
  222                   ;
  223                   ;   Routine to convert (A) into upper case ascii. Only letters
  224                   ; are affected.
  225                   ;
  226 E830  FE 61       UPPER:  CP      'a'             ;check for letters in the range of 'a' to 'z'.
  227 E832  D8                  RET     C
  228 E833  FE 7B               CP      '{'
  229 E835  D0                  RET     NC
  230 E836  E6 5F               AND     5FH             ;convert it if found.
  231 E838  C9                  RET     
  232                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   5
BDOS22  Z80

  233                   ;   Routine to get a line of input. We must check to see if the
  234                   ; user is in (BATCH) mode. If so, then read the input from file
  235                   ; ($$$.SUB). At the end, reset to console input.
  236                   ;
  237 E839  3A EEAB     GETINP: LD      A,(BATCH)       ;if =0, then use console input.
  238 E83C  B7                  OR      A
  239 E83D  CA E896             JP      Z,GETINP1
  240                   ;
  241                   ;   Use the submit file ($$$.sub) which is prepared by a
  242                   ; SUBMIT run. It must be on drive (A) and it will be deleted
  243                   ; if and error occures (like eof).
  244                   ;
  245 E840  3A EEEF             LD      A,(CDRIVE)      ;select drive 0 if need be.
  246 E843  B7                  OR      A
  247 E844  3E 00               LD      A,0             ;always use drive A for submit.
  248 E846  C4 E7BD             CALL    NZ,DSKSEL       ;select it if required.
  249 E849  11 EEAC             LD      DE,BATCHFCB
  250 E84C  CD E7CB             CALL    OPEN            ;look for it.
  251 E84F  CA E896             JP      Z,GETINP1       ;if not there, use normal input.
  252 E852  3A EEBB             LD      A,(BATCHFCB+15) ;get last record number+1.
  253 E855  3D                  DEC     A
  254 E856  32 EECC             LD      (BATCHFCB+32),A
  255 E859  11 EEAC             LD      DE,BATCHFCB
  256 E85C  CD E7F9             CALL    RDREC           ;read last record.
  257 E85F  C2 E896             JP      NZ,GETINP1      ;quit on end of file.
  258                   ;
  259                   ;   Move this record into input buffer.
  260                   ;
  261 E862  11 E707             LD      DE,INBUFF+1
  262 E865  21 0080             LD      HL,TBUFF        ;data was read into buffer here.
  263 E868  06 80               LD      B,128           ;all 128 characters may be used.
  264 E86A  CD EB42             CALL    HL2DE           ;(HL) to (DE), (B) bytes.
  265 E86D  21 EEBA             LD      HL,BATCHFCB+14
  266 E870  36 00               LD      (HL),0          ;zero out the 's2' byte.
  267 E872  23                  INC     HL              ;and decrement the record count.
  268 E873  35                  DEC     (HL)
  269 E874  11 EEAC             LD      DE,BATCHFCB     ;close the batch file now.
  270 E877  CD E7DA             CALL    CLOSE
  271 E87A  CA E896             JP      Z,GETINP1       ;quit on an error.
  272 E87D  3A EEEF             LD      A,(CDRIVE)      ;re-select previous drive if need be.
  273 E880  B7                  OR      A
  274 E881  C4 E7BD             CALL    NZ,DSKSEL       ;don't do needless selects.
  275                   ;
  276                   ;   Print line just read on console.
  277                   ;
  278 E884  21 E708             LD      HL,INBUFF+2
  279 E887  CD E7AC             CALL    PLINE2
  280 E88A  CD E8C2             CALL    CHKCON          ;check console, quit on a key.
  281 E88D  CA E8A7             JP      Z,GETINP2       ;jump if no key is pressed.
  282                   ;
  283                   ;   Terminate the submit job on any keyboard input. Delete this
  284                   ; file such that it is not re-started and jump to normal keyboard
  285                   ; input section.
  286                   ;
  287 E890  CD E8DD             CALL    DELBATCH        ;delete the batch file.
  288 E893  C3 EA82             JP      CMMND1          ;and restart command input.
  289                   ;
  290                   ;   Get here for normal keyboard input. Delete the submit file
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   6
BDOS22  Z80

  291                   ; incase there was one.
  292                   ;
  293 E896  CD E8DD     GETINP1:CALL    DELBATCH        ;delete file ($$$.sub).
  294 E899  CD E81A             CALL    SETCDRV         ;reset active disk.
  295 E89C  0E 0A               LD      C,10            ;get line from console device.
  296 E89E  11 E706             LD      DE,INBUFF
  297 E8A1  CD 0005             CALL    ENTRY
  298 E8A4  CD E829             CALL    MOVECD          ;reset current drive (again).
  299                   ;
  300                   ;   Convert input line to upper case.
  301                   ;
  302 E8A7  21 E707     GETINP2:LD      HL,INBUFF+1
  303 E8AA  46                  LD      B,(HL)          ;(B)=character counter.
  304 E8AB  23          GETINP3:INC     HL
  305 E8AC  78                  LD      A,B             ;end of the line?
  306 E8AD  B7                  OR      A
  307 E8AE  CA E8BA             JP      Z,GETINP4
  308 E8B1  7E                  LD      A,(HL)          ;convert to upper case.
  309 E8B2  CD E830             CALL    UPPER
  310 E8B5  77                  LD      (HL),A
  311 E8B6  05                  DEC     B               ;adjust character count.
  312 E8B7  C3 E8AB             JP      GETINP3
  313 E8BA  77          GETINP4:LD      (HL),A          ;add trailing null.
  314 E8BB  21 E708             LD      HL,INBUFF+2
  315 E8BE  22 E788             LD      (INPOINT),HL    ;reset input line pointer.
  316 E8C1  C9                  RET     
  317                   ;
  318                   ;   Routine to check the console for a key pressed. The zero
  319                   ; flag is set is none, else the character is returned in (A).
  320                   ;
  321 E8C2  0E 0B       CHKCON: LD      C,11            ;check console.
  322 E8C4  CD 0005             CALL    ENTRY
  323 E8C7  B7                  OR      A
  324 E8C8  C8                  RET     Z               ;return if nothing.
  325 E8C9  0E 01               LD      C,1             ;else get character.
  326 E8CB  CD 0005             CALL    ENTRY
  327 E8CE  B7                  OR      A               ;clear zero flag and return.
  328 E8CF  C9                  RET     
  329                   ;
  330                   ;   Routine to get the currently active drive number.
  331                   ;
  332 E8D0  0E 19       GETDSK: LD      C,25
  333 E8D2  C3 0005             JP      ENTRY
  334                   ;
  335                   ;   Set the stabdard dma address.
  336                   ;
  337 E8D5  11 0080     STDDMA: LD      DE,TBUFF
  338                   ;
  339                   ;   Routine to set the dma address to (DE).
  340                   ;
  341 E8D8  0E 1A       DMASET: LD      C,26
  342 E8DA  C3 0005             JP      ENTRY
  343                   ;
  344                   ;  Delete the batch file created by SUBMIT.
  345                   ;
  346 E8DD  21 EEAB     DELBATCH: LD    HL,BATCH        ;is batch active?
  347 E8E0  7E                  LD      A,(HL)
  348 E8E1  B7                  OR      A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   7
BDOS22  Z80

  349 E8E2  C8                  RET     Z
  350 E8E3  36 00               LD      (HL),0          ;yes, de-activate it.
  351 E8E5  AF                  XOR     A
  352 E8E6  CD E7BD             CALL    DSKSEL          ;select drive 0 for sure.
  353 E8E9  11 EEAC             LD      DE,BATCHFCB     ;and delete this file.
  354 E8EC  CD E7EF             CALL    DELETE
  355 E8EF  3A EEEF             LD      A,(CDRIVE)      ;reset current drive.
  356 E8F2  C3 E7BD             JP      DSKSEL
  357                   ;
  358                   ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
  359                   ; the same or we halt....
  360                   ;
  361 E8F5  11 EA28     VERIFY: LD      DE,PATTRN1      ;these are the serial number bytes.
  362 E8F8  21 EF00             LD      HL,PATTRN2      ;ditto, but how could they be different?
  363 E8FB  06 06               LD      B,6             ;6 bytes each.
  364 E8FD  1A          VERIFY1:LD      A,(DE)
  365 E8FE  BE                  CP      (HL)
  366 E8FF  C2 EACF             JP      NZ,HALT         ;jump to halt routine.
  367 E902  13                  INC     DE
  368 E903  23                  INC     HL
  369 E904  05                  DEC     B
  370 E905  C2 E8FD             JP      NZ,VERIFY1
  371 E908  C9                  RET     
  372                   ;
  373                   ;   Print back file name with a '?' to indicate a syntax error.
  374                   ;
  375 E909  CD E798     SYNERR: CALL    CRLF            ;end current line.
  376 E90C  2A E78A             LD      HL,(NAMEPNT)    ;this points to name in error.
  377 E90F  7E          SYNERR1:LD      A,(HL)          ;print it until a space or null is found.
  378 E910  FE 20               CP      ' '
  379 E912  CA E922             JP      Z,SYNERR2
  380 E915  B7                  OR      A
  381 E916  CA E922             JP      Z,SYNERR2
  382 E919  E5                  PUSH    HL
  383 E91A  CD E78C             CALL    PRINT
  384 E91D  E1                  POP     HL
  385 E91E  23                  INC     HL
  386 E91F  C3 E90F             JP      SYNERR1
  387 E922  3E 3F       SYNERR2:LD      A,'?'           ;add trailing '?'.
  388 E924  CD E78C             CALL    PRINT
  389 E927  CD E798             CALL    CRLF
  390 E92A  CD E8DD             CALL    DELBATCH        ;delete any batch file.
  391 E92D  C3 EA82             JP      CMMND1          ;and restart from console input.
  392                   ;
  393                   ;   Check character at (DE) for legal command input. Note that the
  394                   ; zero flag is set if the character is a delimiter.
  395                   ;
  396 E930  1A          CHECK:  LD      A,(DE)
  397 E931  B7                  OR      A
  398 E932  C8                  RET     Z
  399 E933  FE 20               CP      ' '             ;control characters are not legal here.
  400 E935  DA E909             JP      C,SYNERR
  401 E938  C8                  RET     Z               ;check for valid delimiter.
  402 E939  FE 3D               CP      '='
  403 E93B  C8                  RET     Z
  404 E93C  FE 5F               CP      '_'
  405 E93E  C8                  RET     Z
  406 E93F  FE 2E               CP      '.'
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   8
BDOS22  Z80

  407 E941  C8                  RET     Z
  408 E942  FE 3A               CP      ':'
  409 E944  C8                  RET     Z
  410 E945  FE 3B               CP      03BH ; ';'
  411 E947  C8                  RET     Z
  412 E948  FE 3C               CP      '<'
  413 E94A  C8                  RET     Z
  414 E94B  FE 3E               CP      '>'
  415 E94D  C8                  RET     Z
  416 E94E  C9                  RET     
  417                   ;
  418                   ;   Get the next non-blank character from (DE).
  419                   ;
  420 E94F  1A          NONBLANK: LD    A,(DE)
  421 E950  B7                  OR      A               ;string ends with a null.
  422 E951  C8                  RET     Z
  423 E952  FE 20               CP      ' '
  424 E954  C0                  RET     NZ
  425 E955  13                  INC     DE
  426 E956  C3 E94F             JP      NONBLANK
  427                   ;
  428                   ;   Add (HL)=(HL)+(A)
  429                   ;
  430 E959  85          ADDHL:  ADD     A,L
  431 E95A  6F                  LD      L,A
  432 E95B  D0                  RET     NC              ;take care of any carry.
  433 E95C  24                  INC     H
  434 E95D  C9                  RET     
  435                   ;
  436                   ;   Convert the first name in (FCB).
  437                   ;
  438 E95E  3E 00       CONVFST:LD      A,0
  439                   ;
  440                   ;   Format a file name (convert * to '?', etc.). On return,
  441                   ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
  442                   ; the position within the fcb for the name (either 0 or 16).
  443                   ;
  444 E960  21 EECD     CONVERT:LD      HL,FCB
  445 E963  CD E959             CALL    ADDHL
  446 E966  E5                  PUSH    HL
  447 E967  E5                  PUSH    HL
  448 E968  AF                  XOR     A
  449 E969  32 EEF0             LD      (CHGDRV),A      ;initialize drive change flag.
  450 E96C  2A E788             LD      HL,(INPOINT)    ;set (HL) as pointer into input line.
  451 E96F  EB                  EX      DE,HL
  452 E970  CD E94F             CALL    NONBLANK        ;get next non-blank character.
  453 E973  EB                  EX      DE,HL
  454 E974  22 E78A             LD      (NAMEPNT),HL    ;save pointer here for any error message.
  455 E977  EB                  EX      DE,HL
  456 E978  E1                  POP     HL
  457 E979  1A                  LD      A,(DE)          ;get first character.
  458 E97A  B7                  OR      A
  459 E97B  CA E989             JP      Z,CONVRT1
  460 E97E  DE 40               SBC     A,'A'-1         ;might be a drive name, convert to binary.
  461 E980  47                  LD      B,A             ;and save.
  462 E981  13                  INC     DE              ;check next character for a ':'.
  463 E982  1A                  LD      A,(DE)
  464 E983  FE 3A               CP      ':'
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   9
BDOS22  Z80

  465 E985  CA E990             JP      Z,CONVRT2
  466 E988  1B                  DEC     DE              ;nope, move pointer back to the start of the line.
  467 E989  3A EEEF     CONVRT1:LD      A,(CDRIVE)
  468 E98C  77                  LD      (HL),A
  469 E98D  C3 E996             JP      CONVRT3
  470 E990  78          CONVRT2:LD      A,B
  471 E991  32 EEF0             LD      (CHGDRV),A      ;set change in drives flag.
  472 E994  70                  LD      (HL),B
  473 E995  13                  INC     DE
  474                   ;
  475                   ;   Convert the basic file name.
  476                   ;
  477 E996  06 08       CONVRT3:LD      B,08H
  478 E998  CD E930     CONVRT4:CALL    CHECK
  479 E99B  CA E9B9             JP      Z,CONVRT8
  480 E99E  23                  INC     HL
  481 E99F  FE 2A               CP      '*'             ;note that an '*' will fill the remaining
  482 E9A1  C2 E9A9             JP      NZ,CONVRT5      ;field with '?'.
  483 E9A4  36 3F               LD      (HL),'?'
  484 E9A6  C3 E9AB             JP      CONVRT6
  485 E9A9  77          CONVRT5:LD      (HL),A
  486 E9AA  13                  INC     DE
  487 E9AB  05          CONVRT6:DEC     B
  488 E9AC  C2 E998             JP      NZ,CONVRT4
  489 E9AF  CD E930     CONVRT7:CALL    CHECK           ;get next delimiter.
  490 E9B2  CA E9C0             JP      Z,GETEXT
  491 E9B5  13                  INC     DE
  492 E9B6  C3 E9AF             JP      CONVRT7
  493 E9B9  23          CONVRT8:INC     HL              ;blank fill the file name.
  494 E9BA  36 20               LD      (HL),' '
  495 E9BC  05                  DEC     B
  496 E9BD  C2 E9B9             JP      NZ,CONVRT8
  497                   ;
  498                   ;   Get the extension and convert it.
  499                   ;
  500 E9C0  06 03       GETEXT: LD      B,03H
  501 E9C2  FE 2E               CP      '.'
  502 E9C4  C2 E9E9             JP      NZ,GETEXT5
  503 E9C7  13                  INC     DE
  504 E9C8  CD E930     GETEXT1:CALL    CHECK
  505 E9CB  CA E9E9             JP      Z,GETEXT5
  506 E9CE  23                  INC     HL
  507 E9CF  FE 2A               CP      '*'
  508 E9D1  C2 E9D9             JP      NZ,GETEXT2
  509 E9D4  36 3F               LD      (HL),'?'
  510 E9D6  C3 E9DB             JP      GETEXT3
  511 E9D9  77          GETEXT2:LD      (HL),A
  512 E9DA  13                  INC     DE
  513 E9DB  05          GETEXT3:DEC     B
  514 E9DC  C2 E9C8             JP      NZ,GETEXT1
  515 E9DF  CD E930     GETEXT4:CALL    CHECK
  516 E9E2  CA E9F0             JP      Z,GETEXT6
  517 E9E5  13                  INC     DE
  518 E9E6  C3 E9DF             JP      GETEXT4
  519 E9E9  23          GETEXT5:INC     HL
  520 E9EA  36 20               LD      (HL),' '
  521 E9EC  05                  DEC     B
  522 E9ED  C2 E9E9             JP      NZ,GETEXT5
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  10
BDOS22  Z80

  523 E9F0  06 03       GETEXT6:LD      B,3
  524 E9F2  23          GETEXT7:INC     HL
  525 E9F3  36 00               LD      (HL),0
  526 E9F5  05                  DEC     B
  527 E9F6  C2 E9F2             JP      NZ,GETEXT7
  528 E9F9  EB                  EX      DE,HL
  529 E9FA  22 E788             LD      (INPOINT),HL    ;save input line pointer.
  530 E9FD  E1                  POP     HL
  531                   ;
  532                   ;   Check to see if this is an ambigeous file name specification.
  533                   ; Set the (A) register to non zero if it is.
  534                   ;
  535 E9FE  01 000B             LD      BC,11           ;set name length.
  536 EA01  23          GETEXT8:INC     HL
  537 EA02  7E                  LD      A,(HL)
  538 EA03  FE 3F               CP      '?'             ;any question marks?
  539 EA05  C2 EA09             JP      NZ,GETEXT9
  540 EA08  04                  INC     B               ;count them.
  541 EA09  0D          GETEXT9:DEC     C
  542 EA0A  C2 EA01             JP      NZ,GETEXT8
  543 EA0D  78                  LD      A,B
  544 EA0E  B7                  OR      A
  545 EA0F  C9                  RET     
  546                   ;
  547                   ;   CP/M command table. Note commands can be either 3 or 4 characters long.
  548                   ;
  549         0006      NUMCMDS  EQU    6               ;number of commands
  550 EA10  44 49 52 20 CMDTBL:  DB     "DIR "
  551 EA14  45 52 41 20          DB     "ERA "
  552 EA18  54 59 50 45          DB     "TYPE"
  553 EA1C  53 41 56 45          DB     "SAVE"
  554 EA20  52 45 4E 20          DB     "REN "
  555 EA24  55 53 45 52          DB     "USER"
  556                   ;
  557                   ;   The following six bytes must agree with those at (PATTRN2)
  558                   ; or cp/m will HALT. Why?
  559                   ;
  560 EA28  00 16 00 00 PATTRN1: DB     0,22,0,0,0,0    ;(* serial number bytes *).
  561                   ;
  562                   ;   Search the command table for a match with what has just
  563                   ; been entered. If a match is found, then we jump to the
  564                   ; proper section. Else jump to (UNKNOWN).
  565                   ; On return, the (C) register is set to the command number
  566                   ; that matched (or NUMCMDS+1 if no match).
  567                   ;
  568 EA2E  21 EA10     SEARCH: LD      HL,CMDTBL
  569 EA31  0E 00               LD      C,0
  570 EA33  79          SEARCH1:LD      A,C
  571 EA34  FE 06               CP      NUMCMDS         ;this commands exists.
  572 EA36  D0                  RET     NC
  573 EA37  11 EECE             LD      DE,FCB+1        ;check this one.
  574 EA3A  06 04               LD      B,4             ;max command length.
  575 EA3C  1A          SEARCH2:LD      A,(DE)
  576 EA3D  BE                  CP      (HL)
  577 EA3E  C2 EA4F             JP      NZ,SEARCH3      ;not a match.
  578 EA41  13                  INC     DE
  579 EA42  23                  INC     HL
  580 EA43  05                  DEC     B
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  11
BDOS22  Z80

  581 EA44  C2 EA3C             JP      NZ,SEARCH2
  582 EA47  1A                  LD      A,(DE)          ;allow a 3 character command to match.
  583 EA48  FE 20               CP      ' '
  584 EA4A  C2 EA54             JP      NZ,SEARCH4
  585 EA4D  79                  LD      A,C             ;set return register for this command.
  586 EA4E  C9                  RET     
  587 EA4F  23          SEARCH3:INC     HL
  588 EA50  05                  DEC     B
  589 EA51  C2 EA4F             JP      NZ,SEARCH3
  590 EA54  0C          SEARCH4:INC     C
  591 EA55  C3 EA33             JP      SEARCH1
  592                   ;
  593                   ;   Set the input buffer to empty and then start the command
  594                   ; processor (ccp).
  595                   ;
  596 EA58  AF          CLEARBUF: XOR   A
  597 EA59  32 E707             LD      (INBUFF+1),A    ;second byte is actual length.
  598                   ;
  599                   ;**************************************************************
  600                   ;*
  601                   ;*
  602                   ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
  603                   ;*
  604                   ;**************************************************************
  605                   ;*
  606 EA5C  31 EEAB     COMMAND:LD      SP,CCPSTACK     ;setup stack area.
  607 EA5F  C5                  PUSH    BC              ;note that (C) should be equal to:
  608 EA60  79                  LD      A,C             ;(uuuudddd) where 'uuuu' is the user number
  609 EA61  1F                  RRA                     ;and 'dddd' is the drive number.
  610 EA62  1F                  RRA     
  611 EA63  1F                  RRA     
  612 EA64  1F                  RRA     
  613 EA65  E6 0F               AND     0FH             ;isolate the user number.
  614 EA67  5F                  LD      E,A
  615 EA68  CD E815             CALL    GETSETUC        ;and set it.
  616 EA6B  CD E7B8             CALL    RESDSK          ;reset the disk system.
  617 EA6E  32 EEAB             LD      (BATCH),A       ;clear batch mode flag.
  618 EA71  C1                  POP     BC
  619 EA72  79                  LD      A,C
  620 EA73  E6 0F               AND     0FH             ;isolate the drive number.
  621 EA75  32 EEEF             LD      (CDRIVE),A      ;and save.
  622 EA78  CD E7BD             CALL    DSKSEL          ;...and select.
  623 EA7B  3A E707             LD      A,(INBUFF+1)
  624 EA7E  B7                  OR      A               ;anything in input buffer already?
  625 EA7F  C2 EA98             JP      NZ,CMMND2       ;yes, we just process it.
  626                   ;
  627                   ;   Entry point to get a command line from the console.
  628                   ;
  629 EA82  31 EEAB     CMMND1: LD      SP,CCPSTACK     ;set stack straight.
  630 EA85  CD E798             CALL    CRLF            ;start a new line on the screen.
  631 EA88  CD E8D0             CALL    GETDSK          ;get current drive.
  632 EA8B  C6 41               ADD     A,'A'
  633 EA8D  CD E78C             CALL    PRINT           ;print current drive.
  634 EA90  3E 3E               LD      A,'>'
  635 EA92  CD E78C             CALL    PRINT           ;and add prompt.
  636 EA95  CD E839             CALL    GETINP          ;get line from user.
  637                   ;
  638                   ;   Process command line here.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  12
BDOS22  Z80

  639                   ;
  640 EA98  11 0080     CMMND2: LD      DE,TBUFF
  641 EA9B  CD E8D8             CALL    DMASET          ;set standard dma address.
  642 EA9E  CD E8D0             CALL    GETDSK
  643 EAA1  32 EEEF             LD      (CDRIVE),A      ;set current drive.
  644 EAA4  CD E95E             CALL    CONVFST         ;convert name typed in.
  645 EAA7  C4 E909             CALL    NZ,SYNERR       ;wild cards are not allowed.
  646 EAAA  3A EEF0             LD      A,(CHGDRV)      ;if a change in drives was indicated,
  647 EAAD  B7                  OR      A               ;then treat this as an unknown command
  648 EAAE  C2 EDA5             JP      NZ,UNKNOWN      ;which gets executed.
  649 EAB1  CD EA2E             CALL    SEARCH          ;else search command table for a match.
  650                   ;
  651                   ;   Note that an unknown command returns
  652                   ; with (A) pointing to the last address
  653                   ; in our table which is (UNKNOWN).
  654                   ;
  655 EAB4  21 EAC1             LD      HL,CMDADR       ;now, look thru our address table for command (A).
  656 EAB7  5F                  LD      E,A             ;set (DE) to command number.
  657 EAB8  16 00               LD      D,0
  658 EABA  19                  ADD     HL,DE
  659 EABB  19                  ADD     HL,DE           ;(HL)=(CMDADR)+2*(command number).
  660 EABC  7E                  LD      A,(HL)          ;now pick out this address.
  661 EABD  23                  INC     HL
  662 EABE  66                  LD      H,(HL)
  663 EABF  6F                  LD      L,A
  664 EAC0  E9                  JP      (HL)            ;now execute it.
  665                   ;
  666                   ;   CP/M command address table.
  667                   ;
  668 EAC1  EB77  EC1F  CMDADR:  DW     DIRECT,ERASE,TYPE,SAVE
  669 EAC9  ED10  ED8E           DW     RENAME,USER,UNKNOWN
  670                   ;
  671                   ;   Halt the system. Reason for this is unknown at present.
  672                   ;
  673 EACF  21 76F3     HALT:   LD      HL,76F3H        ;'DI HLT' instructions.
  674 EAD2  22 E700             LD      (CBASE),HL
  675 EAD5  21 E700             LD      HL,CBASE
  676 EAD8  E9                  JP      (HL)
  677                   ;
  678                   ;   Read error while TYPEing a file.
  679                   ;
  680 EAD9  01 EADF     RDERROR:LD      BC,RDERR
  681 EADC  C3 E7A7             JP      PLINE
  682 EADF  52 65 61 64 RDERR:   DB     "Read error"
  683 EAE9  00                   DB     0
  684                   ;
  685                   ;   Required file was not located.
  686                   ;
  687 EAEA  01 EAF0     NONE:   LD      BC,NOFILE
  688 EAED  C3 E7A7             JP      PLINE
  689 EAF0  4E 6F 20 66 NOFILE:  DB     "No file"
  690 EAF7  00                   DB     0
  691                   ;
  692                   ;   Decode a command of the form 'A>filename number{ filename}.
  693                   ; Note that a drive specifier is not allowed on the first file
  694                   ; name. On return, the number is in register (A). Any error
  695                   ; causes 'filename?' to be printed and the command is aborted.
  696                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  13
BDOS22  Z80

  697 EAF8  CD E95E     DECODE: CALL    CONVFST         ;convert filename.
  698 EAFB  3A EEF0             LD      A,(CHGDRV)      ;do not allow a drive to be specified.
  699 EAFE  B7                  OR      A
  700 EAFF  C2 E909             JP      NZ,SYNERR
  701 EB02  21 EECE             LD      HL,FCB+1        ;convert number now.
  702 EB05  01 000B             LD      BC,11           ;(B)=sum register, (C)=max digit count.
  703 EB08  7E          DECODE1:LD      A,(HL)
  704 EB09  FE 20               CP      ' '             ;a space terminates the numeral.
  705 EB0B  CA EB33             JP      Z,DECODE3
  706 EB0E  23                  INC     HL
  707 EB0F  D6 30               SUB     '0'             ;make binary from ascii.
  708 EB11  FE 0A               CP      10              ;legal digit?
  709 EB13  D2 E909             JP      NC,SYNERR
  710 EB16  57                  LD      D,A             ;yes, save it in (D).
  711 EB17  78                  LD      A,B             ;compute (B)=(B)*10 and check for overflow.
  712 EB18  E6 E0               AND     0E0H
  713 EB1A  C2 E909             JP      NZ,SYNERR
  714 EB1D  78                  LD      A,B
  715 EB1E  07                  RLCA    
  716 EB1F  07                  RLCA    
  717 EB20  07                  RLCA                    ;(A)=(B)*8
  718 EB21  80                  ADD     A,B             ;.......*9
  719 EB22  DA E909             JP      C,SYNERR
  720 EB25  80                  ADD     A,B             ;.......*10
  721 EB26  DA E909             JP      C,SYNERR
  722 EB29  82                  ADD     A,D             ;add in new digit now.
  723 EB2A  DA E909     DECODE2:JP      C,SYNERR
  724 EB2D  47                  LD      B,A             ;and save result.
  725 EB2E  0D                  DEC     C               ;only look at 11 digits.
  726 EB2F  C2 EB08             JP      NZ,DECODE1
  727 EB32  C9                  RET     
  728 EB33  7E          DECODE3:LD      A,(HL)          ;spaces must follow (why?).
  729 EB34  FE 20               CP      ' '
  730 EB36  C2 E909             JP      NZ,SYNERR
  731 EB39  23                  INC     HL
  732 EB3A  0D          DECODE4:DEC     C
  733 EB3B  C2 EB33             JP      NZ,DECODE3
  734 EB3E  78                  LD      A,B             ;set (A)=the numeric value entered.
  735 EB3F  C9                  RET     
  736                   ;
  737                   ;   Move 3 bytes from (HL) to (DE). Note that there is only
  738                   ; one reference to this at (A2D5h).
  739                   ;
  740 EB40  06 03       MOVE3:  LD      B,3
  741                   ;
  742                   ;   Move (B) bytes from (HL) to (DE).
  743                   ;
  744 EB42  7E          HL2DE:  LD      A,(HL)
  745 EB43  12                  LD      (DE),A
  746 EB44  23                  INC     HL
  747 EB45  13                  INC     DE
  748 EB46  05                  DEC     B
  749 EB47  C2 EB42             JP      NZ,HL2DE
  750 EB4A  C9                  RET     
  751                   ;
  752                   ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
  753                   ;
  754 EB4B  21 0080     EXTRACT:LD      HL,TBUFF
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  14
BDOS22  Z80

  755 EB4E  81                  ADD     A,C
  756 EB4F  CD E959             CALL    ADDHL
  757 EB52  7E                  LD      A,(HL)
  758 EB53  C9                  RET     
  759                   ;
  760                   ;  Check drive specified. If it means a change, then the new
  761                   ; drive will be selected. In any case, the drive byte of the
  762                   ; fcb will be set to null (means use current drive).
  763                   ;
  764 EB54  AF          DSELECT:XOR     A               ;null out first byte of fcb.
  765 EB55  32 EECD             LD      (FCB),A
  766 EB58  3A EEF0             LD      A,(CHGDRV)      ;a drive change indicated?
  767 EB5B  B7                  OR      A
  768 EB5C  C8                  RET     Z
  769 EB5D  3D                  DEC     A               ;yes, is it the same as the current drive?
  770 EB5E  21 EEEF             LD      HL,CDRIVE
  771 EB61  BE                  CP      (HL)
  772 EB62  C8                  RET     Z
  773 EB63  C3 E7BD             JP      DSKSEL          ;no. Select it then.
  774                   ;
  775                   ;   Check the drive selection and reset it to the previous
  776                   ; drive if it was changed for the preceeding command.
  777                   ;
  778 EB66  3A EEF0     RESETDR:LD      A,(CHGDRV)      ;drive change indicated?
  779 EB69  B7                  OR      A
  780 EB6A  C8                  RET     Z
  781 EB6B  3D                  DEC     A               ;yes, was it a different drive?
  782 EB6C  21 EEEF             LD      HL,CDRIVE
  783 EB6F  BE                  CP      (HL)
  784 EB70  C8                  RET     Z
  785 EB71  3A EEEF             LD      A,(CDRIVE)      ;yes, re-select our old drive.
  786 EB74  C3 E7BD             JP      DSKSEL
  787                   ;
  788                   ;**************************************************************
  789                   ;*
  790                   ;*           D I R E C T O R Y   C O M M A N D
  791                   ;*
  792                   ;**************************************************************
  793                   ;
  794 EB77  CD E95E     DIRECT: CALL    CONVFST         ;convert file name.
  795 EB7A  CD EB54             CALL    DSELECT         ;select indicated drive.
  796 EB7D  21 EECE             LD      HL,FCB+1        ;was any file indicated?
  797 EB80  7E                  LD      A,(HL)
  798 EB81  FE 20               CP      ' '
  799 EB83  C2 EB8F             JP      NZ,DIRECT2
  800 EB86  06 0B               LD      B,11            ;no. Fill field with '?' - same as *.*.
  801 EB88  36 3F       DIRECT1:LD      (HL),'?'
  802 EB8A  23                  INC     HL
  803 EB8B  05                  DEC     B
  804 EB8C  C2 EB88             JP      NZ,DIRECT1
  805 EB8F  1E 00       DIRECT2:LD      E,0             ;set initial cursor position.
  806 EB91  D5                  PUSH    DE
  807 EB92  CD E7E9             CALL    SRCHFCB         ;get first file name.
  808 EB95  CC EAEA             CALL    Z,NONE          ;none found at all?
  809 EB98  CA EC1B     DIRECT3:JP      Z,DIRECT9       ;terminate if no more names.
  810 EB9B  3A EEEE             LD      A,(RTNCODE)     ;get file's position in segment (0-3).
  811 EB9E  0F                  RRCA    
  812 EB9F  0F                  RRCA    
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  15
BDOS22  Z80

  813 EBA0  0F                  RRCA    
  814 EBA1  E6 60               AND     60H             ;(A)=position*32
  815 EBA3  4F                  LD      C,A
  816 EBA4  3E 0A               LD      A,10
  817 EBA6  CD EB4B             CALL    EXTRACT         ;extract the tenth entry in fcb.
  818 EBA9  17                  RLA                     ;check system file status bit.
  819 EBAA  DA EC0F             JP      C,DIRECT8       ;we don't list them.
  820 EBAD  D1                  POP     DE
  821 EBAE  7B                  LD      A,E             ;bump name count.
  822 EBAF  1C                  INC     E
  823 EBB0  D5                  PUSH    DE
  824 EBB1  E6 03               AND     03H             ;at end of line?
  825 EBB3  F5                  PUSH    AF
  826 EBB4  C2 EBCC             JP      NZ,DIRECT4
  827 EBB7  CD E798             CALL    CRLF            ;yes, end this line and start another.
  828 EBBA  C5                  PUSH    BC
  829 EBBB  CD E8D0             CALL    GETDSK          ;start line with ('A:').
  830 EBBE  C1                  POP     BC
  831 EBBF  C6 41               ADD     A,'A'
  832 EBC1  CD E792             CALL    PRINTB
  833 EBC4  3E 3A               LD      A,':'
  834 EBC6  CD E792             CALL    PRINTB
  835 EBC9  C3 EBD4             JP      DIRECT5
  836 EBCC  CD E7A2     DIRECT4:CALL    SPACE           ;add seperator between file names.
  837 EBCF  3E 3A               LD      A,':'
  838 EBD1  CD E792             CALL    PRINTB
  839 EBD4  CD E7A2     DIRECT5:CALL    SPACE
  840 EBD7  06 01               LD      B,1             ;'extract' each file name character at a time.
  841 EBD9  78          DIRECT6:LD      A,B
  842 EBDA  CD EB4B             CALL    EXTRACT
  843 EBDD  E6 7F               AND     7FH             ;strip bit 7 (status bit).
  844 EBDF  FE 20               CP      ' '             ;are we at the end of the name?
  845 EBE1  C2 EBF9             JP      NZ,DRECT65
  846 EBE4  F1                  POP     AF              ;yes, don't print spaces at the end of a line.
  847 EBE5  F5                  PUSH    AF
  848 EBE6  FE 03               CP      3
  849 EBE8  C2 EBF7             JP      NZ,DRECT63
  850 EBEB  3E 09               LD      A,9             ;first check for no extension.
  851 EBED  CD EB4B             CALL    EXTRACT
  852 EBF0  E6 7F               AND     7FH
  853 EBF2  FE 20               CP      ' '
  854 EBF4  CA EC0E             JP      Z,DIRECT7       ;don't print spaces.
  855 EBF7  3E 20       DRECT63:LD      A,' '           ;else print them.
  856 EBF9  CD E792     DRECT65:CALL    PRINTB
  857 EBFC  04                  INC     B               ;bump to next character psoition.
  858 EBFD  78                  LD      A,B
  859 EBFE  FE 0C               CP      12              ;end of the name?
  860 EC00  D2 EC0E             JP      NC,DIRECT7
  861 EC03  FE 09               CP      9               ;nope, starting extension?
  862 EC05  C2 EBD9             JP      NZ,DIRECT6
  863 EC08  CD E7A2             CALL    SPACE           ;yes, add seperating space.
  864 EC0B  C3 EBD9             JP      DIRECT6
  865 EC0E  F1          DIRECT7:POP     AF              ;get the next file name.
  866 EC0F  CD E8C2     DIRECT8:CALL    CHKCON          ;first check console, quit on anything.
  867 EC12  C2 EC1B             JP      NZ,DIRECT9
  868 EC15  CD E7E4             CALL    SRCHNXT         ;get next name.
  869 EC18  C3 EB98             JP      DIRECT3         ;and continue with our list.
  870 EC1B  D1          DIRECT9:POP     DE              ;restore the stack and return to command level.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  16
BDOS22  Z80

  871 EC1C  C3 EE86             JP      GETBACK
  872                   ;
  873                   ;**************************************************************
  874                   ;*
  875                   ;*                E R A S E   C O M M A N D
  876                   ;*
  877                   ;**************************************************************
  878                   ;
  879 EC1F  CD E95E     ERASE:  CALL    CONVFST         ;convert file name.
  880 EC22  FE 0B               CP      11              ;was '*.*' entered?
  881 EC24  C2 EC42             JP      NZ,ERASE1
  882 EC27  01 EC52             LD      BC,YESNO        ;yes, ask for confirmation.
  883 EC2A  CD E7A7             CALL    PLINE
  884 EC2D  CD E839             CALL    GETINP
  885 EC30  21 E707             LD      HL,INBUFF+1
  886 EC33  35                  DEC     (HL)            ;must be exactly 'y'.
  887 EC34  C2 EA82             JP      NZ,CMMND1
  888 EC37  23                  INC     HL
  889 EC38  7E                  LD      A,(HL)
  890 EC39  FE 59               CP      'Y'
  891 EC3B  C2 EA82             JP      NZ,CMMND1
  892 EC3E  23                  INC     HL
  893 EC3F  22 E788             LD      (INPOINT),HL    ;save input line pointer.
  894 EC42  CD EB54     ERASE1: CALL    DSELECT         ;select desired disk.
  895 EC45  11 EECD             LD      DE,FCB
  896 EC48  CD E7EF             CALL    DELETE          ;delete the file.
  897 EC4B  3C                  INC     A
  898 EC4C  CC EAEA             CALL    Z,NONE          ;not there?
  899 EC4F  C3 EE86             JP      GETBACK         ;return to command level now.
  900 EC52  41 6C 6C 20 YESNO:   DB     "All (y/n)?"
  901 EC5C  00                   DB     0
  902                   ;
  903                   ;**************************************************************
  904                   ;*
  905                   ;*            T Y P E   C O M M A N D
  906                   ;*
  907                   ;**************************************************************
  908                   ;
  909 EC5D  CD E95E     TYPE:   CALL    CONVFST         ;convert file name.
  910 EC60  C2 E909             JP      NZ,SYNERR       ;wild cards not allowed.
  911 EC63  CD EB54             CALL    DSELECT         ;select indicated drive.
  912 EC66  CD E7D0             CALL    OPENFCB         ;open the file.
  913 EC69  CA ECA7             JP      Z,TYPE5         ;not there?
  914 EC6C  CD E798             CALL    CRLF            ;ok, start a new line on the screen.
  915 EC6F  21 EEF1             LD      HL,NBYTES       ;initialize byte counter.
  916 EC72  36 FF               LD      (HL),0FFH       ;set to read first sector.
  917 EC74  21 EEF1     TYPE1:  LD      HL,NBYTES
  918 EC77  7E          TYPE2:  LD      A,(HL)          ;have we written the entire sector?
  919 EC78  FE 80               CP      128
  920 EC7A  DA EC87             JP      C,TYPE3
  921 EC7D  E5                  PUSH    HL              ;yes, read in the next one.
  922 EC7E  CD E7FE             CALL    READFCB
  923 EC81  E1                  POP     HL
  924 EC82  C2 ECA0             JP      NZ,TYPE4        ;end or error?
  925 EC85  AF                  XOR     A               ;ok, clear byte counter.
  926 EC86  77                  LD      (HL),A
  927 EC87  34          TYPE3:  INC     (HL)            ;count this byte.
  928 EC88  21 0080             LD      HL,TBUFF        ;and get the (A)th one from the buffer (TBUFF).
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  17
BDOS22  Z80

  929 EC8B  CD E959             CALL    ADDHL
  930 EC8E  7E                  LD      A,(HL)
  931 EC8F  FE 1A               CP      CNTRLZ          ;end of file mark?
  932 EC91  CA EE86             JP      Z,GETBACK
  933 EC94  CD E78C             CALL    PRINT           ;no, print it.
  934 EC97  CD E8C2             CALL    CHKCON          ;check console, quit if anything ready.
  935 EC9A  C2 EE86             JP      NZ,GETBACK
  936 EC9D  C3 EC74             JP      TYPE1
  937                   ;
  938                   ;   Get here on an end of file or read error.
  939                   ;
  940 ECA0  3D          TYPE4:  DEC     A               ;read error?
  941 ECA1  CA EE86             JP      Z,GETBACK
  942 ECA4  CD EAD9             CALL    RDERROR         ;yes, print message.
  943 ECA7  CD EB66     TYPE5:  CALL    RESETDR         ;and reset proper drive
  944 ECAA  C3 E909             JP      SYNERR          ;now print file name with problem.
  945                   ;
  946                   ;**************************************************************
  947                   ;*
  948                   ;*            S A V E   C O M M A N D
  949                   ;*
  950                   ;**************************************************************
  951                   ;
  952 ECAD  CD EAF8     SAVE:   CALL    DECODE          ;get numeric number that follows SAVE.
  953 ECB0  F5                  PUSH    AF              ;save number of pages to write.
  954 ECB1  CD E95E             CALL    CONVFST         ;convert file name.
  955 ECB4  C2 E909             JP      NZ,SYNERR       ;wild cards not allowed.
  956 ECB7  CD EB54             CALL    DSELECT         ;select specified drive.
  957 ECBA  11 EECD             LD      DE,FCB          ;now delete this file.
  958 ECBD  D5                  PUSH    DE
  959 ECBE  CD E7EF             CALL    DELETE
  960 ECC1  D1                  POP     DE
  961 ECC2  CD E809             CALL    CREATE          ;and create it again.
  962 ECC5  CA ECFB             JP      Z,SAVE3         ;can't create?
  963 ECC8  AF                  XOR     A               ;clear record number byte.
  964 ECC9  32 EEED             LD      (FCB+32),A
  965 ECCC  F1                  POP     AF              ;convert pages to sectors.
  966 ECCD  6F                  LD      L,A
  967 ECCE  26 00               LD      H,0
  968 ECD0  29                  ADD     HL,HL           ;(HL)=number of sectors to write.
  969 ECD1  11 0100             LD      DE,TBASE        ;and we start from here.
  970 ECD4  7C          SAVE1:  LD      A,H             ;done yet?
  971 ECD5  B5                  OR      L
  972 ECD6  CA ECF1             JP      Z,SAVE2
  973 ECD9  2B                  DEC     HL              ;nope, count this and compute the start
  974 ECDA  E5                  PUSH    HL              ;of the next 128 byte sector.
  975 ECDB  21 0080             LD      HL,128
  976 ECDE  19                  ADD     HL,DE
  977 ECDF  E5                  PUSH    HL              ;save it and set the transfer address.
  978 ECE0  CD E8D8             CALL    DMASET
  979 ECE3  11 EECD             LD      DE,FCB          ;write out this sector now.
  980 ECE6  CD E804             CALL    WRTREC
  981 ECE9  D1                  POP     DE              ;reset (DE) to the start of the last sector.
  982 ECEA  E1                  POP     HL              ;restore sector count.
  983 ECEB  C2 ECFB             JP      NZ,SAVE3        ;write error?
  984 ECEE  C3 ECD4             JP      SAVE1
  985                   ;
  986                   ;   Get here after writing all of the file.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  18
BDOS22  Z80

  987                   ;
  988 ECF1  11 EECD     SAVE2:  LD      DE,FCB          ;now close the file.
  989 ECF4  CD E7DA             CALL    CLOSE
  990 ECF7  3C                  INC     A               ;did it close ok?
  991 ECF8  C2 ED01             JP      NZ,SAVE4
  992                   ;
  993                   ;   Print out error message (no space).
  994                   ;
  995 ECFB  01 ED07     SAVE3:  LD      BC,NOSPACE
  996 ECFE  CD E7A7             CALL    PLINE
  997 ED01  CD E8D5     SAVE4:  CALL    STDDMA          ;reset the standard dma address.
  998 ED04  C3 EE86             JP      GETBACK
  999 ED07  4E 6F 20 73 NOSPACE: DB     "No space"
 1000 ED0F  00                   DB     0
 1001                   ;
 1002                   ;**************************************************************
 1003                   ;*
 1004                   ;*           R E N A M E   C O M M A N D
 1005                   ;*
 1006                   ;**************************************************************
 1007                   ;
 1008 ED10  CD E95E     RENAME: CALL    CONVFST         ;convert first file name.
 1009 ED13  C2 E909             JP      NZ,SYNERR       ;wild cards not allowed.
 1010 ED16  3A EEF0             LD      A,(CHGDRV)      ;remember any change in drives specified.
 1011 ED19  F5                  PUSH    AF
 1012 ED1A  CD EB54             CALL    DSELECT         ;and select this drive.
 1013 ED1D  CD E7E9             CALL    SRCHFCB         ;is this file present?
 1014 ED20  C2 ED79             JP      NZ,RENAME6      ;yes, print error message.
 1015 ED23  21 EECD             LD      HL,FCB          ;yes, move this name into second slot.
 1016 ED26  11 EEDD             LD      DE,FCB+16
 1017 ED29  06 10               LD      B,16
 1018 ED2B  CD EB42             CALL    HL2DE
 1019 ED2E  2A E788             LD      HL,(INPOINT)    ;get input pointer.
 1020 ED31  EB                  EX      DE,HL
 1021 ED32  CD E94F             CALL    NONBLANK        ;get next non blank character.
 1022 ED35  FE 3D               CP      '='             ;only allow an '=' or '_' seperator.
 1023 ED37  CA ED3F             JP      Z,RENAME1
 1024 ED3A  FE 5F               CP      '_'
 1025 ED3C  C2 ED73             JP      NZ,RENAME5
 1026 ED3F  EB          RENAME1:EX      DE,HL
 1027 ED40  23                  INC     HL              ;ok, skip seperator.
 1028 ED41  22 E788             LD      (INPOINT),HL    ;save input line pointer.
 1029 ED44  CD E95E             CALL    CONVFST         ;convert this second file name now.
 1030 ED47  C2 ED73             JP      NZ,RENAME5      ;again, no wild cards.
 1031 ED4A  F1                  POP     AF              ;if a drive was specified, then it
 1032 ED4B  47                  LD      B,A             ;must be the same as before.
 1033 ED4C  21 EEF0             LD      HL,CHGDRV
 1034 ED4F  7E                  LD      A,(HL)
 1035 ED50  B7                  OR      A
 1036 ED51  CA ED59             JP      Z,RENAME2
 1037 ED54  B8                  CP      B
 1038 ED55  70                  LD      (HL),B
 1039 ED56  C2 ED73             JP      NZ,RENAME5      ;they were different, error.
 1040 ED59  70          RENAME2:LD      (HL),B          ;       reset as per the first file specification.
 1041 ED5A  AF                  XOR     A
 1042 ED5B  32 EECD             LD      (FCB),A         ;clear the drive byte of the fcb.
 1043 ED5E  CD E7E9     RENAME3:CALL    SRCHFCB         ;and go look for second file.
 1044 ED61  CA ED6D             JP      Z,RENAME4       ;doesn't exist?
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  19
BDOS22  Z80

 1045 ED64  11 EECD             LD      DE,FCB
 1046 ED67  CD E80E             CALL    RENAM           ;ok, rename the file.
 1047 ED6A  C3 EE86             JP      GETBACK
 1048                   ;
 1049                   ;   Process rename errors here.
 1050                   ;
 1051 ED6D  CD EAEA     RENAME4:CALL    NONE            ;file not there.
 1052 ED70  C3 EE86             JP      GETBACK
 1053 ED73  CD EB66     RENAME5:CALL    RESETDR         ;bad command format.
 1054 ED76  C3 E909             JP      SYNERR
 1055 ED79  01 ED82     RENAME6:LD      BC,EXISTS       ;destination file already exists.
 1056 ED7C  CD E7A7             CALL    PLINE
 1057 ED7F  C3 EE86             JP      GETBACK
 1058 ED82  46 69 6C 65 EXISTS:  DB     "File exists"
 1059 ED8D  00                   DB     0
 1060                   ;
 1061                   ;**************************************************************
 1062                   ;*
 1063                   ;*             U S E R   C O M M A N D
 1064                   ;*
 1065                   ;**************************************************************
 1066                   ;
 1067 ED8E  CD EAF8     USER:   CALL    DECODE          ;get numeric value following command.
 1068 ED91  FE 10               CP      16              ;legal user number?
 1069 ED93  D2 E909             JP      NC,SYNERR
 1070 ED96  5F                  LD      E,A             ;yes but is there anything else?
 1071 ED97  3A EECE             LD      A,(FCB+1)
 1072 ED9A  FE 20               CP      ' '
 1073 ED9C  CA E909             JP      Z,SYNERR        ;yes, that is not allowed.
 1074 ED9F  CD E815             CALL    GETSETUC        ;ok, set user code.
 1075 EDA2  C3 EE89             JP      GETBACK1
 1076                   ;
 1077                   ;**************************************************************
 1078                   ;*
 1079                   ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
 1080                   ;*
 1081                   ;**************************************************************
 1082                   ;
 1083 EDA5  CD E8F5     UNKNOWN:CALL    VERIFY          ;check for valid system (why?).
 1084 EDA8  3A EECE             LD      A,(FCB+1)       ;anything to execute?
 1085 EDAB  FE 20               CP      ' '
 1086 EDAD  C2 EDC4             JP      NZ,UNKWN1
 1087 EDB0  3A EEF0             LD      A,(CHGDRV)      ;nope, only a drive change?
 1088 EDB3  B7                  OR      A
 1089 EDB4  CA EE89             JP      Z,GETBACK1      ;neither???
 1090 EDB7  3D                  DEC     A
 1091 EDB8  32 EEEF             LD      (CDRIVE),A      ;ok, store new drive.
 1092 EDBB  CD E829             CALL    MOVECD          ;set (TDRIVE) also.
 1093 EDBE  CD E7BD             CALL    DSKSEL          ;and select this drive.
 1094 EDC1  C3 EE89             JP      GETBACK1        ;then return.
 1095                   ;
 1096                   ;   Here a file name was typed. Prepare to execute it.
 1097                   ;
 1098 EDC4  11 EED6     UNKWN1: LD      DE,FCB+9        ;an extension specified?
 1099 EDC7  1A                  LD      A,(DE)
 1100 EDC8  FE 20               CP      ' '
 1101 EDCA  C2 E909             JP      NZ,SYNERR       ;yes, not allowed.
 1102 EDCD  D5          UNKWN2: PUSH    DE
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  20
BDOS22  Z80

 1103 EDCE  CD EB54             CALL    DSELECT         ;select specified drive.
 1104 EDD1  D1                  POP     DE
 1105 EDD2  21 EE83             LD      HL,COMFILE      ;set the extension to 'COM'.
 1106 EDD5  CD EB40             CALL    MOVE3
 1107 EDD8  CD E7D0             CALL    OPENFCB         ;and open this file.
 1108 EDDB  CA EE6B             JP      Z,UNKWN9        ;not present?
 1109                   ;
 1110                   ;   Load in the program.
 1111                   ;
 1112 EDDE  21 0100             LD      HL,TBASE        ;store the program starting here.
 1113 EDE1  E5          UNKWN3: PUSH    HL
 1114 EDE2  EB                  EX      DE,HL
 1115 EDE3  CD E8D8             CALL    DMASET          ;set transfer address.
 1116 EDE6  11 EECD             LD      DE,FCB          ;and read the next record.
 1117 EDE9  CD E7F9             CALL    RDREC
 1118 EDEC  C2 EE01             JP      NZ,UNKWN4       ;end of file or read error?
 1119 EDEF  E1                  POP     HL              ;nope, bump pointer for next sector.
 1120 EDF0  11 0080             LD      DE,128
 1121 EDF3  19                  ADD     HL,DE
 1122 EDF4  11 E700             LD      DE,CBASE        ;enough room for the whole file?
 1123 EDF7  7D                  LD      A,L
 1124 EDF8  93                  SUB     E
 1125 EDF9  7C                  LD      A,H
 1126 EDFA  9A                  SBC     A,D
 1127 EDFB  D2 EE71             JP      NC,UNKWN0       ;no, it can't fit.
 1128 EDFE  C3 EDE1             JP      UNKWN3
 1129                   ;
 1130                   ;   Get here after finished reading.
 1131                   ;
 1132 EE01  E1          UNKWN4: POP     HL
 1133 EE02  3D                  DEC     A               ;normal end of file?
 1134 EE03  C2 EE71             JP      NZ,UNKWN0
 1135 EE06  CD EB66             CALL    RESETDR         ;yes, reset previous drive.
 1136 EE09  CD E95E             CALL    CONVFST         ;convert the first file name that follows
 1137 EE0C  21 EEF0             LD      HL,CHGDRV       ;command name.
 1138 EE0F  E5                  PUSH    HL
 1139 EE10  7E                  LD      A,(HL)          ;set drive code in default fcb.
 1140 EE11  32 EECD             LD      (FCB),A
 1141 EE14  3E 10               LD      A,16            ;put second name 16 bytes later.
 1142 EE16  CD E960             CALL    CONVERT         ;convert second file name.
 1143 EE19  E1                  POP     HL
 1144 EE1A  7E                  LD      A,(HL)          ;and set the drive for this second file.
 1145 EE1B  32 EEDD             LD      (FCB+16),A
 1146 EE1E  AF                  XOR     A               ;clear record byte in fcb.
 1147 EE1F  32 EEED             LD      (FCB+32),A
 1148 EE22  11 005C             LD      DE,TFCB         ;move it into place at(005Ch).
 1149 EE25  21 EECD             LD      HL,FCB
 1150 EE28  06 21               LD      B,33
 1151 EE2A  CD EB42             CALL    HL2DE
 1152 EE2D  21 E708             LD      HL,INBUFF+2     ;now move the remainder of the input
 1153 EE30  7E          UNKWN5: LD      A,(HL)          ;line down to (0080h). Look for a non blank.
 1154 EE31  B7                  OR      A               ;or a null.
 1155 EE32  CA EE3E             JP      Z,UNKWN6
 1156 EE35  FE 20               CP      ' '
 1157 EE37  CA EE3E             JP      Z,UNKWN6
 1158 EE3A  23                  INC     HL
 1159 EE3B  C3 EE30             JP      UNKWN5
 1160                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  21
BDOS22  Z80

 1161                   ;   Do the line move now. It ends in a null byte.
 1162                   ;
 1163 EE3E  06 00       UNKWN6: LD      B,0             ;keep a character count.
 1164 EE40  11 0081             LD      DE,TBUFF+1      ;data gets put here.
 1165 EE43  7E          UNKWN7: LD      A,(HL)          ;move it now.
 1166 EE44  12                  LD      (DE),A
 1167 EE45  B7                  OR      A
 1168 EE46  CA EE4F             JP      Z,UNKWN8
 1169 EE49  04                  INC     B
 1170 EE4A  23                  INC     HL
 1171 EE4B  13                  INC     DE
 1172 EE4C  C3 EE43             JP      UNKWN7
 1173 EE4F  78          UNKWN8: LD      A,B             ;now store the character count.
 1174 EE50  32 0080             LD      (TBUFF),A
 1175 EE53  CD E798             CALL    CRLF            ;clean up the screen.
 1176 EE56  CD E8D5             CALL    STDDMA          ;set standard transfer address.
 1177 EE59  CD E81A             CALL    SETCDRV         ;reset current drive.
 1178 EE5C  CD 0100             CALL    TBASE           ;and execute the program.
 1179                   ;
 1180                   ;   Transiant programs return here (or reboot).
 1181                   ;
 1182 EE5F  31 EEAB             LD      SP,BATCH        ;set stack first off.
 1183 EE62  CD E829             CALL    MOVECD          ;move current drive into place (TDRIVE).
 1184 EE65  CD E7BD             CALL    DSKSEL          ;and reselect it.
 1185 EE68  C3 EA82             JP      CMMND1          ;back to comand mode.
 1186                   ;
 1187                   ;   Get here if some error occured.
 1188                   ;
 1189 EE6B  CD EB66     UNKWN9: CALL    RESETDR         ;inproper format.
 1190 EE6E  C3 E909             JP      SYNERR
 1191 EE71  01 EE7A     UNKWN0: LD      BC,BADLOAD      ;read error or won't fit.
 1192 EE74  CD E7A7             CALL    PLINE
 1193 EE77  C3 EE86             JP      GETBACK
 1194 EE7A  42 61 64 20 BADLOAD: DB     "Bad load"
 1195 EE82  00                   DB     0
 1196 EE83  43 4F 4D    COMFILE: DB     "COM"           ;command file extension.
 1197                   ;
 1198                   ;   Get here to return to command level. We will reset the
 1199                   ; previous active drive and then either return to command
 1200                   ; level directly or print error message and then return.
 1201                   ;
 1202 EE86  CD EB66     GETBACK:CALL    RESETDR         ;reset previous drive.
 1203 EE89  CD E95E     GETBACK1: CALL  CONVFST         ;convert first name in (FCB).
 1204 EE8C  3A EECE             LD      A,(FCB+1)       ;if this was just a drive change request,
 1205 EE8F  D6 20               SUB     ' '             ;make sure it was valid.
 1206 EE91  21 EEF0             LD      HL,CHGDRV
 1207 EE94  B6                  OR      (HL)
 1208 EE95  C2 E909             JP      NZ,SYNERR
 1209 EE98  C3 EA82             JP      CMMND1          ;ok, return to command level.
 1210                   ;
 1211                   ;   ccp stack area.
 1212                   ;
 1213 EE9B  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1214         EEAB      CCPSTACK  EQU   $       ;end of ccp stack area.
 1215                   ;
 1216                   ;   Batch (or SUBMIT) processing information storage.
 1217                   ;
 1218 EEAB  00          BATCH:   DB     0               ;batch mode flag (0=not active).
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  22
BDOS22  Z80

 1219 EEAC  00          BATCHFCB:  DB   0,
 1220 EEAD  24 24 24 20          DB   "$$$     SUB"
 1221 EEB8  00 00 00 00          DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1222                   ;
 1223                   ;   File control block setup by the CCP.
 1224                   ;
 1225 EECD  00          FCB:     DB     0
 1226 EECE  20 20 20 20          DB     "           "
 1227 EED9  00 00 00 00          DB     0,0,0,0,0
 1228 EEDE  20 20 20 20          DB     "           "
 1229 EEE9  00 00 00 00          DB     0,0,0,0,0
 1230 EEEE  00          RTNCODE: DB     0               ;status returned from bdos call.
 1231 EEEF  00          CDRIVE:  DB     0               ;currently active drive.
 1232 EEF0  00          CHGDRV:  DB     0               ;change in drives flag (0=no change).
 1233 EEF1  0000        NBYTES:  DW     0               ;byte counter used by TYPE.
 1234                   ;
 1235                   ;   Room for expansion?
 1236                   ;
 1237 EEF3  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0
 1238                   ;
 1239                   ;   Note that the following six bytes must match those at
 1240                   ; (PATTRN1) or cp/m will HALT. Why?
 1241                   ;
 1242 EF00  00 16 00 00 PATTRN2: DB     0,22,0,0,0,0    ;(* serial number bytes *).
 1243                   ;
 1244                   ;**************************************************************
 1245                   ;*
 1246                   ;*                    B D O S   E N T R Y
 1247                   ;*
 1248                   ;**************************************************************
 1249                   ;
 1250 EF06  C3 EF11     FBASE:  JP      FBASE1
 1251                   ;
 1252                   ;   Bdos error table.
 1253                   ;
 1254 EF09  EF99        BADSCTR: DW     ERROR1          ;bad sector on read or write.
 1255 EF0B  EFA5        BADSLCT: DW     ERROR2          ;bad disk select.
 1256 EF0D  EFAB        RODISK:  DW     ERROR3          ;disk is read only.
 1257 EF0F  EFB1        ROFILE:  DW     ERROR4          ;file is read only.
 1258                   ;
 1259                   ;   Entry into bdos. (DE) or (E) are the parameters passed. The
 1260                   ; function number desired is in register (C).
 1261                   ;
 1262 EF11  EB          FBASE1: EX      DE,HL           ;save the (DE) parameters.
 1263 EF12  22 F243             LD      (PARAMS),HL
 1264 EF15  EB                  EX      DE,HL
 1265 EF16  7B                  LD      A,E             ;and save register (E) in particular.
 1266 EF17  32 FCD6             LD      (EPARAM),A
 1267 EF1A  21 0000             LD      HL,0
 1268 EF1D  22 F245             LD      (STATUS),HL     ;clear return status.
 1269 EF20  39                  ADD     HL,SP
 1270 EF21  22 F20F             LD      (USRSTACK),HL   ;save users stack pointer.
 1271 EF24  31 F241             LD      SP,STKAREA      ;and set our own.
 1272 EF27  AF                  XOR     A               ;clear auto select storage space.
 1273 EF28  32 FCE0             LD      (AUTOFLAG),A
 1274 EF2B  32 FCDE             LD      (AUTO),A
 1275 EF2E  21 FC74             LD      HL,GOBACK       ;set return address.
 1276 EF31  E5                  PUSH    HL
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  23
BDOS22  Z80

 1277 EF32  79                  LD      A,C             ;get function number.
 1278 EF33  FE 29               CP      NFUNCTS         ;valid function number?
 1279 EF35  D0                  RET     NC
 1280 EF36  4B                  LD      C,E             ;keep single register function here.
 1281 EF37  21 EF47             LD      HL,FUNCTNS      ;now look thru the function table.
 1282 EF3A  5F                  LD      E,A
 1283 EF3B  16 00               LD      D,0             ;(DE)=function number.
 1284 EF3D  19                  ADD     HL,DE
 1285 EF3E  19                  ADD     HL,DE           ;(HL)=(start of table)+2*(function number).
 1286 EF3F  5E                  LD      E,(HL)
 1287 EF40  23                  INC     HL
 1288 EF41  56                  LD      D,(HL)          ;now (DE)=address for this function.
 1289 EF42  2A F243             LD      HL,(PARAMS)     ;retrieve parameters.
 1290 EF45  EB                  EX      DE,HL           ;now (DE) has the original parameters.
 1291 EF46  E9                  JP      (HL)            ;execute desired function.
 1292                   ;
 1293                   ;   BDOS function jump table.
 1294                   ;
 1295         0029      NFUNCTS  EQU    41              ;number of functions in followin table.
 1296                   ;
 1297 EF47  FD03  F1C8  FUNCTNS: DW     WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
 1298 EF57  F1F3  F1F8           DW     SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
 1299 EF67  FBA5  FBAB           DW     CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
 1300 EF75  FBF5  FBFE           DW     RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
 1301 EF85  FC26  FC2D           DW     GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
 1302 EF95  F204  FC9B           DW     RTN,WTSPECL
 1303                   ;
 1304                   ;   Bdos error message section.
 1305                   ;
 1306 EF99  21 EFCA     ERROR1: LD      HL,BADSEC       ;bad sector message.
 1307 EF9C  CD EFE5             CALL    PRTERR          ;print it and get a 1 char responce.
 1308 EF9F  FE 03               CP      CNTRLC          ;re-boot request (control-c)?
 1309 EFA1  CA 0000             JP      Z,0             ;yes.
 1310 EFA4  C9                  RET                     ;no, return to retry i/o function.
 1311                   ;
 1312 EFA5  21 EFD5     ERROR2: LD      HL,BADSEL       ;bad drive selected.
 1313 EFA8  C3 EFB4             JP      ERROR5
 1314                   ;
 1315 EFAB  21 EFE1     ERROR3: LD      HL,DISKRO       ;disk is read only.
 1316 EFAE  C3 EFB4             JP      ERROR5
 1317                   ;
 1318 EFB1  21 EFDC     ERROR4: LD      HL,FILERO       ;file is read only.
 1319                   ;
 1320 EFB4  CD EFE5     ERROR5: CALL    PRTERR
 1321 EFB7  C3 0000             JP      0               ;always reboot on these errors.
 1322                   ;
 1323 EFBA  42 64 6F 73 BDOSERR: DB     "Bdos Err On "
 1324 EFC6  20 3A 20 24 BDOSDRV: DB     " : $"
 1325 EFCA  42 61 64 20 BADSEC:  DB     "Bad Sector$"
 1326 EFD5  53 65 6C 65 BADSEL:  DB     "Select$"
 1327 EFDC  46 69 6C 65 FILERO:  DB     "File "
 1328 EFE1  52 2F 4F 24 DISKRO:  DB     "R/O$"
 1329                   ;
 1330                   ;   Print bdos error message.
 1331                   ;
 1332 EFE5  E5          PRTERR: PUSH    HL              ;save second message pointer.
 1333 EFE6  CD F0C9             CALL    OUTCRLF         ;send (cr)(lf).
 1334 EFE9  3A F242             LD      A,(ACTIVE)      ;get active drive.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  24
BDOS22  Z80

 1335 EFEC  C6 41               ADD     A,'A'           ;make ascii.
 1336 EFEE  32 EFC6             LD      (BDOSDRV),A     ;and put in message.
 1337 EFF1  01 EFBA             LD      BC,BDOSERR      ;and print it.
 1338 EFF4  CD F0D3             CALL    PRTMESG
 1339 EFF7  C1                  POP     BC              ;print second message line now.
 1340 EFF8  CD F0D3             CALL    PRTMESG
 1341                   ;
 1342                   ;   Get an input character. We will check our 1 character
 1343                   ; buffer first. This may be set by the console status routine.
 1344                   ;
 1345 EFFB  21 F20E     GETCHAR:LD      HL,CHARBUF      ;check character buffer.
 1346 EFFE  7E                  LD      A,(HL)          ;anything present already?
 1347 EFFF  36 00               LD      (HL),0          ;...either case clear it.
 1348 F001  B7                  OR      A
 1349 F002  C0                  RET     NZ              ;yes, use it.
 1350 F003  C3 FD09             JP      CONIN           ;nope, go get a character responce.
 1351                   ;
 1352                   ;   Input and echo a character.
 1353                   ;
 1354 F006  CD EFFB     GETECHO:CALL    GETCHAR         ;input a character.
 1355 F009  CD F014             CALL    CHKCHAR         ;carriage control?
 1356 F00C  D8                  RET     C               ;no, a regular control char so don't echo.
 1357 F00D  F5                  PUSH    AF              ;ok, save character now.
 1358 F00E  4F                  LD      C,A
 1359 F00F  CD F090             CALL    OUTCON          ;and echo it.
 1360 F012  F1                  POP     AF              ;get character and return.
 1361 F013  C9                  RET     
 1362                   ;
 1363                   ;   Check character in (A). Set the zero flag on a carriage
 1364                   ; control character and the carry flag on any other control
 1365                   ; character.
 1366                   ;
 1367 F014  FE 0D       CHKCHAR:CP      CR              ;check for carriage return, line feed, backspace,
 1368 F016  C8                  RET     Z               ;or a tab.
 1369 F017  FE 0A               CP      LF
 1370 F019  C8                  RET     Z
 1371 F01A  FE 09               CP      TAB
 1372 F01C  C8                  RET     Z
 1373 F01D  FE 08               CP      BS
 1374 F01F  C8                  RET     Z
 1375 F020  FE 20               CP      ' '             ;other control char? Set carry flag.
 1376 F022  C9                  RET     
 1377                   ;
 1378                   ;   Check the console during output. Halt on a control-s, then
 1379                   ; reboot on a control-c. If anything else is ready, clear the
 1380                   ; zero flag and return (the calling routine may want to do
 1381                   ; something).
 1382                   ;
 1383 F023  3A F20E     CKCONSOL: LD    A,(CHARBUF)     ;check buffer.
 1384 F026  B7                  OR      A               ;if anything, just return without checking.
 1385 F027  C2 F045             JP      NZ,CKCON2
 1386 F02A  CD FD06             CALL    CONST           ;nothing in buffer. Check console.
 1387 F02D  E6 01               AND     01H             ;look at bit 0.
 1388 F02F  C8                  RET     Z               ;return if nothing.
 1389 F030  CD FD09             CALL    CONIN           ;ok, get it.
 1390 F033  FE 13               CP      CNTRLS          ;if not control-s, return with zero cleared.
 1391 F035  C2 F042             JP      NZ,CKCON1
 1392 F038  CD FD09             CALL    CONIN           ;halt processing until another char
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  25
BDOS22  Z80

 1393 F03B  FE 03               CP      CNTRLC          ;is typed. Control-c?
 1394 F03D  CA 0000             JP      Z,0             ;yes, reboot now.
 1395 F040  AF                  XOR     A               ;no, just pretend nothing was ever ready.
 1396 F041  C9                  RET     
 1397 F042  32 F20E     CKCON1: LD      (CHARBUF),A     ;save character in buffer for later processing.
 1398 F045  3E 01       CKCON2: LD      A,1             ;set (A) to non zero to mean something is ready.
 1399 F047  C9                  RET     
 1400                   ;
 1401                   ;   Output (C) to the screen. If the printer flip-flop flag
 1402                   ; is set, we will send character to printer also. The console
 1403                   ; will be checked in the process.
 1404                   ;
 1405 F048  3A F20A     OUTCHAR:LD      A,(OUTFLAG)     ;check output flag.
 1406 F04B  B7                  OR      A               ;anything and we won't generate output.
 1407 F04C  C2 F062             JP      NZ,OUTCHR1
 1408 F04F  C5                  PUSH    BC
 1409 F050  CD F023             CALL    CKCONSOL        ;check console (we don't care whats there).
 1410 F053  C1                  POP     BC
 1411 F054  C5                  PUSH    BC
 1412 F055  CD FD0C             CALL    CONOUT          ;output (C) to the screen.
 1413 F058  C1                  POP     BC
 1414 F059  C5                  PUSH    BC
 1415 F05A  3A F20D             LD      A,(PRTFLAG)     ;check printer flip-flop flag.
 1416 F05D  B7                  OR      A
 1417 F05E  C4 FD0F             CALL    NZ,LIST         ;print it also if non-zero.
 1418 F061  C1                  POP     BC
 1419 F062  79          OUTCHR1:LD      A,C             ;update cursors position.
 1420 F063  21 F20C             LD      HL,CURPOS
 1421 F066  FE 7F               CP      DEL             ;rubouts don't do anything here.
 1422 F068  C8                  RET     Z
 1423 F069  34                  INC     (HL)            ;bump line pointer.
 1424 F06A  FE 20               CP      ' '             ;and return if a normal character.
 1425 F06C  D0                  RET     NC
 1426 F06D  35                  DEC     (HL)            ;restore and check for the start of the line.
 1427 F06E  7E                  LD      A,(HL)
 1428 F06F  B7                  OR      A
 1429 F070  C8                  RET     Z               ;ingnore control characters at the start of the line.
 1430 F071  79                  LD      A,C
 1431 F072  FE 08               CP      BS              ;is it a backspace?
 1432 F074  C2 F079             JP      NZ,OUTCHR2
 1433 F077  35                  DEC     (HL)            ;yes, backup pointer.
 1434 F078  C9                  RET     
 1435 F079  FE 0A       OUTCHR2:CP      LF              ;is it a line feed?
 1436 F07B  C0                  RET     NZ              ;ignore anything else.
 1437 F07C  36 00               LD      (HL),0          ;reset pointer to start of line.
 1438 F07E  C9                  RET     
 1439                   ;
 1440                   ;   Output (A) to the screen. If it is a control character
 1441                   ; (other than carriage control), use ^x format.
 1442                   ;
 1443 F07F  79          SHOWIT: LD      A,C
 1444 F080  CD F014             CALL    CHKCHAR         ;check character.
 1445 F083  D2 F090             JP      NC,OUTCON       ;not a control, use normal output.
 1446 F086  F5                  PUSH    AF
 1447 F087  0E 5E               LD      C,'^'           ;for a control character, preceed it with '^'.
 1448 F089  CD F048             CALL    OUTCHAR
 1449 F08C  F1                  POP     AF
 1450 F08D  F6 40               OR      '@'             ;and then use the letter equivelant.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  26
BDOS22  Z80

 1451 F08F  4F                  LD      C,A
 1452                   ;
 1453                   ;   Function to output (C) to the console device and expand tabs
 1454                   ; if necessary.
 1455                   ;
 1456 F090  79          OUTCON: LD      A,C
 1457 F091  FE 09               CP      TAB             ;is it a tab?
 1458 F093  C2 F048             JP      NZ,OUTCHAR      ;use regular output.
 1459 F096  0E 20       OUTCON1:LD      C,' '           ;yes it is, use spaces instead.
 1460 F098  CD F048             CALL    OUTCHAR
 1461 F09B  3A F20C             LD      A,(CURPOS)      ;go until the cursor is at a multiple of 8
 1462                   
 1463 F09E  E6 07               AND     07H             ;position.
 1464 F0A0  C2 F096             JP      NZ,OUTCON1
 1465 F0A3  C9                  RET     
 1466                   ;
 1467                   ;   Echo a backspace character. Erase the prevoius character
 1468                   ; on the screen.
 1469                   ;
 1470 F0A4  CD F0AC     BACKUP: CALL    BACKUP1         ;backup the screen 1 place.
 1471 F0A7  0E 20               LD      C,' '           ;then blank that character.
 1472 F0A9  CD FD0C             CALL    CONOUT
 1473 F0AC  0E 08       BACKUP1:LD      C,BS            ;then back space once more.
 1474 F0AE  C3 FD0C             JP      CONOUT
 1475                   ;
 1476                   ;   Signal a deleted line. Print a '#' at the end and start
 1477                   ; over.
 1478                   ;
 1479 F0B1  0E 23       NEWLINE:LD      C,'#'
 1480 F0B3  CD F048             CALL    OUTCHAR         ;print this.
 1481 F0B6  CD F0C9             CALL    OUTCRLF         ;start new line.
 1482 F0B9  3A F20C     NEWLN1: LD      A,(CURPOS)      ;move the cursor to the starting position.
 1483 F0BC  21 F20B             LD      HL,STARTING
 1484 F0BF  BE                  CP      (HL)
 1485 F0C0  D0                  RET     NC              ;there yet?
 1486 F0C1  0E 20               LD      C,' '
 1487 F0C3  CD F048             CALL    OUTCHAR         ;nope, keep going.
 1488 F0C6  C3 F0B9             JP      NEWLN1
 1489                   ;
 1490                   ;   Output a (cr) (lf) to the console device (screen).
 1491                   ;
 1492 F0C9  0E 0D       OUTCRLF:LD      C,CR
 1493 F0CB  CD F048             CALL    OUTCHAR
 1494 F0CE  0E 0A               LD      C,LF
 1495 F0D0  C3 F048             JP      OUTCHAR
 1496                   ;
 1497                   ;   Print message pointed to by (BC). It will end with a '$'.
 1498                   ;
 1499 F0D3  0A          PRTMESG:LD      A,(BC)          ;check for terminating character.
 1500 F0D4  FE 24               CP      '$'
 1501 F0D6  C8                  RET     Z
 1502 F0D7  03                  INC     BC
 1503 F0D8  C5                  PUSH    BC              ;otherwise, bump pointer and print it.
 1504 F0D9  4F                  LD      C,A
 1505 F0DA  CD F090             CALL    OUTCON
 1506 F0DD  C1                  POP     BC
 1507 F0DE  C3 F0D3             JP      PRTMESG
 1508                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  27
BDOS22  Z80

 1509                   ;   Function to execute a buffered read.
 1510                   ;
 1511 F0E1  3A F20C     RDBUFF: LD      A,(CURPOS)      ;use present location as starting one.
 1512 F0E4  32 F20B             LD      (STARTING),A
 1513 F0E7  2A F243             LD      HL,(PARAMS)     ;get the maximum buffer space.
 1514 F0EA  4E                  LD      C,(HL)
 1515 F0EB  23                  INC     HL              ;point to first available space.
 1516 F0EC  E5                  PUSH    HL              ;and save.
 1517 F0ED  06 00               LD      B,0             ;keep a character count.
 1518 F0EF  C5          RDBUF1: PUSH    BC
 1519 F0F0  E5                  PUSH    HL
 1520 F0F1  CD EFFB     RDBUF2: CALL    GETCHAR         ;get the next input character.
 1521 F0F4  E6 7F               AND     7FH             ;strip bit 7.
 1522 F0F6  E1                  POP     HL              ;reset registers.
 1523 F0F7  C1                  POP     BC
 1524 F0F8  FE 0D               CP      CR              ;en of the line?
 1525 F0FA  CA F1C1             JP      Z,RDBUF17
 1526 F0FD  FE 0A               CP      LF
 1527 F0FF  CA F1C1             JP      Z,RDBUF17
 1528 F102  FE 08               CP      BS              ;how about a backspace?
 1529 F104  C2 F116             JP      NZ,RDBUF3
 1530 F107  78                  LD      A,B             ;yes, but ignore at the beginning of the line.
 1531 F108  B7                  OR      A
 1532 F109  CA F0EF             JP      Z,RDBUF1
 1533 F10C  05                  DEC     B               ;ok, update counter.
 1534 F10D  3A F20C             LD      A,(CURPOS)      ;if we backspace to the start of the line,
 1535 F110  32 F20A             LD      (OUTFLAG),A     ;treat as a cancel (control-x).
 1536 F113  C3 F170             JP      RDBUF10
 1537 F116  FE 7F       RDBUF3: CP      DEL             ;user typed a rubout?
 1538 F118  C2 F126             JP      NZ,RDBUF4
 1539 F11B  78                  LD      A,B             ;ignore at the start of the line.
 1540 F11C  B7                  OR      A
 1541 F11D  CA F0EF             JP      Z,RDBUF1
 1542 F120  7E                  LD      A,(HL)          ;ok, echo the prevoius character.
 1543 F121  05                  DEC     B               ;and reset pointers (counters).
 1544 F122  2B                  DEC     HL
 1545 F123  C3 F1A9             JP      RDBUF15
 1546 F126  FE 05       RDBUF4: CP      CNTRLE          ;physical end of line?
 1547 F128  C2 F137             JP      NZ,RDBUF5
 1548 F12B  C5                  PUSH    BC              ;yes, do it.
 1549 F12C  E5                  PUSH    HL
 1550 F12D  CD F0C9             CALL    OUTCRLF
 1551 F130  AF                  XOR     A               ;and update starting position.
 1552 F131  32 F20B             LD      (STARTING),A
 1553 F134  C3 F0F1             JP      RDBUF2
 1554 F137  FE 10       RDBUF5: CP      CNTRLP          ;control-p?
 1555 F139  C2 F148             JP      NZ,RDBUF6
 1556 F13C  E5                  PUSH    HL              ;yes, flip the print flag filp-flop byte.
 1557 F13D  21 F20D             LD      HL,PRTFLAG
 1558 F140  3E 01               LD      A,1             ;PRTFLAG=1-PRTFLAG
 1559 F142  96                  SUB     (HL)
 1560 F143  77                  LD      (HL),A
 1561 F144  E1                  POP     HL
 1562 F145  C3 F0EF             JP      RDBUF1
 1563 F148  FE 18       RDBUF6: CP      CNTRLX          ;control-x (cancel)?
 1564 F14A  C2 F15F             JP      NZ,RDBUF8
 1565 F14D  E1                  POP     HL
 1566 F14E  3A F20B     RDBUF7: LD      A,(STARTING)    ;yes, backup the cursor to here.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  28
BDOS22  Z80

 1567 F151  21 F20C             LD      HL,CURPOS
 1568 F154  BE                  CP      (HL)
 1569 F155  D2 F0E1             JP      NC,RDBUFF       ;done yet?
 1570 F158  35                  DEC     (HL)            ;no, decrement pointer and output back up one space.
 1571 F159  CD F0A4             CALL    BACKUP
 1572 F15C  C3 F14E             JP      RDBUF7
 1573 F15F  FE 15       RDBUF8: CP      CNTRLU          ;cntrol-u (cancel line)?
 1574 F161  C2 F16B             JP      NZ,RDBUF9
 1575 F164  CD F0B1             CALL    NEWLINE         ;start a new line.
 1576 F167  E1                  POP     HL
 1577 F168  C3 F0E1             JP      RDBUFF
 1578 F16B  FE 12       RDBUF9: CP      CNTRLR          ;control-r?
 1579 F16D  C2 F1A6             JP      NZ,RDBUF14
 1580 F170  C5          RDBUF10:PUSH    BC              ;yes, start a new line and retype the old one.
 1581 F171  CD F0B1             CALL    NEWLINE
 1582 F174  C1                  POP     BC
 1583 F175  E1                  POP     HL
 1584 F176  E5                  PUSH    HL
 1585 F177  C5                  PUSH    BC
 1586 F178  78          RDBUF11:LD      A,B             ;done whole line yet?
 1587 F179  B7                  OR      A
 1588 F17A  CA F18A             JP      Z,RDBUF12
 1589 F17D  23                  INC     HL              ;nope, get next character.
 1590 F17E  4E                  LD      C,(HL)
 1591 F17F  05                  DEC     B               ;count it.
 1592 F180  C5                  PUSH    BC
 1593 F181  E5                  PUSH    HL
 1594 F182  CD F07F             CALL    SHOWIT          ;and display it.
 1595 F185  E1                  POP     HL
 1596 F186  C1                  POP     BC
 1597 F187  C3 F178             JP      RDBUF11
 1598 F18A  E5          RDBUF12:PUSH    HL              ;done with line. If we were displaying
 1599 F18B  3A F20A             LD      A,(OUTFLAG)     ;then update cursor position.
 1600 F18E  B7                  OR      A
 1601 F18F  CA F0F1             JP      Z,RDBUF2
 1602 F192  21 F20C             LD      HL,CURPOS       ;because this line is shorter, we must
 1603 F195  96                  SUB     (HL)            ;back up the cursor (not the screen however)
 1604 F196  32 F20A             LD      (OUTFLAG),A     ;some number of positions.
 1605 F199  CD F0A4     RDBUF13:CALL    BACKUP          ;note that as long as (OUTFLAG) is non
 1606 F19C  21 F20A             LD      HL,OUTFLAG      ;zero, the screen will not be changed.
 1607 F19F  35                  DEC     (HL)
 1608 F1A0  C2 F199             JP      NZ,RDBUF13
 1609 F1A3  C3 F0F1             JP      RDBUF2          ;now just get the next character.
 1610                   ;
 1611                   ;   Just a normal character, put this in our buffer and echo.
 1612                   ;
 1613 F1A6  23          RDBUF14:INC     HL
 1614 F1A7  77                  LD      (HL),A          ;store character.
 1615 F1A8  04                  INC     B               ;and count it.
 1616 F1A9  C5          RDBUF15:PUSH    BC
 1617 F1AA  E5                  PUSH    HL
 1618 F1AB  4F                  LD      C,A             ;echo it now.
 1619 F1AC  CD F07F             CALL    SHOWIT
 1620 F1AF  E1                  POP     HL
 1621 F1B0  C1                  POP     BC
 1622 F1B1  7E                  LD      A,(HL)          ;was it an abort request?
 1623 F1B2  FE 03               CP      CNTRLC          ;control-c abort?
 1624 F1B4  78                  LD      A,B
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  29
BDOS22  Z80

 1625 F1B5  C2 F1BD             JP      NZ,RDBUF16
 1626 F1B8  FE 01               CP      1               ;only if at start of line.
 1627 F1BA  CA 0000             JP      Z,0
 1628 F1BD  B9          RDBUF16:CP      C               ;nope, have we filled the buffer?
 1629 F1BE  DA F0EF             JP      C,RDBUF1
 1630 F1C1  E1          RDBUF17:POP     HL              ;yes end the line and return.
 1631 F1C2  70                  LD      (HL),B
 1632 F1C3  0E 0D               LD      C,CR
 1633 F1C5  C3 F048             JP      OUTCHAR         ;output (cr) and return.
 1634                   ;
 1635                   ;   Function to get a character from the console device.
 1636                   ;
 1637 F1C8  CD F006     GETCON: CALL    GETECHO         ;get and echo.
 1638 F1CB  C3 F201             JP      SETSTAT         ;save status and return.
 1639                   ;
 1640                   ;   Function to get a character from the tape reader device.
 1641                   ;
 1642 F1CE  CD FD15     GETRDR: CALL    READER          ;get a character from reader, set status and return.
 1643 F1D1  C3 F201             JP      SETSTAT
 1644                   ;
 1645                   ;  Function to perform direct console i/o. If (C) contains (FF)
 1646                   ; then this is an input request. If (C) contains (FE) then
 1647                   ; this is a status request. Otherwise we are to output (C).
 1648                   ;
 1649 F1D4  79          DIRCIO: LD      A,C             ;test for (FF).
 1650 F1D5  3C                  INC     A
 1651 F1D6  CA F1E0             JP      Z,DIRC1
 1652 F1D9  3C                  INC     A               ;test for (FE).
 1653 F1DA  CA FD06             JP      Z,CONST
 1654 F1DD  C3 FD0C             JP      CONOUT          ;just output (C).
 1655 F1E0  CD FD06     DIRC1:  CALL    CONST           ;this is an input request.
 1656 F1E3  B7                  OR      A
 1657 F1E4  CA FC91             JP      Z,GOBACK1       ;not ready? Just return (directly).
 1658 F1E7  CD FD09             CALL    CONIN           ;yes, get character.
 1659 F1EA  C3 F201             JP      SETSTAT         ;set status and return.
 1660                   ;
 1661                   ;   Function to return the i/o byte.
 1662                   ;
 1663 F1ED  3A 0003     GETIOB: LD      A,(IOBYTE)
 1664 F1F0  C3 F201             JP      SETSTAT
 1665                   ;
 1666                   ;   Function to set the i/o byte.
 1667                   ;
 1668 F1F3  21 0003     SETIOB: LD      HL,IOBYTE
 1669 F1F6  71                  LD      (HL),C
 1670 F1F7  C9                  RET     
 1671                   ;
 1672                   ;   Function to print the character string pointed to by (DE)
 1673                   ; on the console device. The string ends with a '$'.
 1674                   ;
 1675 F1F8  EB          PRTSTR: EX      DE,HL
 1676 F1F9  4D                  LD      C,L
 1677 F1FA  44                  LD      B,H             ;now (BC) points to it.
 1678 F1FB  C3 F0D3             JP      PRTMESG
 1679                   ;
 1680                   ;   Function to interigate the console device.
 1681                   ;
 1682 F1FE  CD F023     GETCSTS:CALL    CKCONSOL
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  30
BDOS22  Z80

 1683                   ;
 1684                   ;   Get here to set the status and return to the cleanup
 1685                   ; section. Then back to the user.
 1686                   ;
 1687 F201  32 F245     SETSTAT:LD      (STATUS),A
 1688 F204  C9          RTN:    RET     
 1689                   ;
 1690                   ;   Set the status to 1 (read or write error code).
 1691                   ;
 1692 F205  3E 01       IOERR1: LD      A,1
 1693 F207  C3 F201             JP      SETSTAT
 1694                   ;
 1695 F20A  00          OUTFLAG: DB     0               ;output flag (non zero means no output).
 1696 F20B  02          STARTING:  DB   2               ;starting position for cursor.
 1697 F20C  00          CURPOS:  DB     0               ;cursor position (0=start of line).
 1698 F20D  00          PRTFLAG: DB     0               ;printer flag (control-p toggle). List if non zero.
 1699 F20E  00          CHARBUF: DB     0               ;single input character buffer.
 1700                   ;
 1701                   ;   Stack area for BDOS calls.
 1702                   ;
 1703 F20F  0000        USRSTACK:  DW   0               ;save users stack pointer here.
 1704                   ;
 1705 F211  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1706 F229  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1707         F241      STKAREA  EQU    $               ;end of stack area.
 1708                   ;
 1709 F241  00          USERNO:  DB     0               ;current user number.
 1710 F242  00          ACTIVE:  DB     0               ;currently active drive.
 1711 F243  0000        PARAMS:  DW     0               ;save (DE) parameters here on entry.
 1712 F245  0000        STATUS:  DW     0               ;status returned from bdos function.
 1713                   ;
 1714                   ;   Select error occured, jump to error routine.
 1715                   ;
 1716 F247  21 EF0B     SLCTERR:LD      HL,BADSLCT
 1717                   ;
 1718                   ;   Jump to (HL) indirectly.
 1719                   ;
 1720 F24A  5E          JUMPHL: LD      E,(HL)
 1721 F24B  23                  INC     HL
 1722 F24C  56                  LD      D,(HL)          ;now (DE) contain the desired address.
 1723 F24D  EB                  EX      DE,HL
 1724 F24E  E9                  JP      (HL)
 1725                   ;
 1726                   ;   Block move. (DE) to (HL), (C) bytes total.
 1727                   ;
 1728 F24F  0C          DE2HL:  INC     C               ;is count down to zero?
 1729 F250  0D          DE2HL1: DEC     C
 1730 F251  C8                  RET     Z               ;yes, we are done.
 1731 F252  1A                  LD      A,(DE)          ;no, move one more byte.
 1732 F253  77                  LD      (HL),A
 1733 F254  13                  INC     DE
 1734 F255  23                  INC     HL
 1735 F256  C3 F250             JP      DE2HL1          ;and repeat.
 1736                   ;
 1737                   ;   Select the desired drive.
 1738                   ;
 1739 F259  3A F242     SELECT: LD      A,(ACTIVE)      ;get active disk.
 1740 F25C  4F                  LD      C,A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  31
BDOS22  Z80

 1741 F25D  CD FD1B             CALL    SELDSK          ;select it.
 1742 F260  7C                  LD      A,H             ;valid drive?
 1743 F261  B5                  OR      L               ;valid drive?
 1744 F262  C8                  RET     Z               ;return if not.
 1745                   ;
 1746                   ;   Here, the BIOS returned the address of the parameter block
 1747                   ; in (HL). We will extract the necessary pointers and save them.
 1748                   ;
 1749 F263  5E                  LD      E,(HL)          ;yes, get address of translation table into (DE).
 1750 F264  23                  INC     HL
 1751 F265  56                  LD      D,(HL)
 1752 F266  23                  INC     HL
 1753 F267  22 FCB3             LD      (SCRATCH1),HL   ;save pointers to scratch areas.
 1754 F26A  23                  INC     HL
 1755 F26B  23                  INC     HL
 1756 F26C  22 FCB5             LD      (SCRATCH2),HL   ;ditto.
 1757 F26F  23                  INC     HL
 1758 F270  23                  INC     HL
 1759 F271  22 FCB7             LD      (SCRATCH3),HL   ;ditto.
 1760 F274  23                  INC     HL
 1761 F275  23                  INC     HL
 1762 F276  EB                  EX      DE,HL           ;now save the translation table address.
 1763 F277  22 FCD0             LD      (XLATE),HL
 1764 F27A  21 FCB9             LD      HL,DIRBUF       ;put the next 8 bytes here.
 1765 F27D  0E 08               LD      C,8             ;they consist of the directory buffer
 1766 F27F  CD F24F             CALL    DE2HL           ;pointer, parameter block pointer,
 1767 F282  2A FCBB             LD      HL,(DISKPB)     ;check and allocation vectors.
 1768 F285  EB                  EX      DE,HL
 1769 F286  21 FCC1             LD      HL,SECTORS      ;move parameter block into our ram.
 1770 F289  0E 0F               LD      C,15            ;it is 15 bytes long.
 1771 F28B  CD F24F             CALL    DE2HL
 1772 F28E  2A FCC6             LD      HL,(DSKSIZE)    ;check disk size.
 1773 F291  7C                  LD      A,H             ;more than 256 blocks on this?
 1774 F292  21 FCDD             LD      HL,BIGDISK
 1775 F295  36 FF               LD      (HL),0FFH       ;set to samll.
 1776 F297  B7                  OR      A
 1777 F298  CA F29D             JP      Z,SELECT1
 1778 F29B  36 00               LD      (HL),0          ;wrong, set to large.
 1779 F29D  3E FF       SELECT1:LD      A,0FFH          ;clear the zero flag.
 1780 F29F  B7                  OR      A
 1781 F2A0  C9                  RET     
 1782                   ;
 1783                   ;   Routine to home the disk track head and clear pointers.
 1784                   ;
 1785 F2A1  CD FD18     HOMEDRV:CALL    HOME            ;home the head.
 1786 F2A4  AF                  XOR     A
 1787 F2A5  2A FCB5             LD      HL,(SCRATCH2)   ;set our track pointer also.
 1788 F2A8  77                  LD      (HL),A
 1789 F2A9  23                  INC     HL
 1790 F2AA  77                  LD      (HL),A
 1791 F2AB  2A FCB7             LD      HL,(SCRATCH3)   ;and our sector pointer.
 1792 F2AE  77                  LD      (HL),A
 1793 F2AF  23                  INC     HL
 1794 F2B0  77                  LD      (HL),A
 1795 F2B1  C9                  RET     
 1796                   ;
 1797                   ;   Do the actual disk read and check the error return status.
 1798                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  32
BDOS22  Z80

 1799 F2B2  CD FD27     DOREAD: CALL    READ
 1800 F2B5  C3 F2BB             JP      IORET
 1801                   ;
 1802                   ;   Do the actual disk write and handle any bios error.
 1803                   ;
 1804 F2B8  CD FD2A     DOWRITE:CALL    WRITE
 1805 F2BB  B7          IORET:  OR      A
 1806 F2BC  C8                  RET     Z               ;return unless an error occured.
 1807 F2BD  21 EF09             LD      HL,BADSCTR      ;bad read/write on this sector.
 1808 F2C0  C3 F24A             JP      JUMPHL
 1809                   ;
 1810                   ;   Routine to select the track and sector that the desired
 1811                   ; block number falls in.
 1812                   ;
 1813 F2C3  2A FCEA     TRKSEC: LD      HL,(FILEPOS)    ;get position of last accessed file
 1814 F2C6  0E 02               LD      C,2             ;in directory and compute sector #.
 1815 F2C8  CD F3EA             CALL    SHIFTR          ;sector #=file-position/4.
 1816 F2CB  22 FCE5             LD      (BLKNMBR),HL    ;save this as the block number of interest.
 1817 F2CE  22 FCEC             LD      (CKSUMTBL),HL   ;what's it doing here too?
 1818                   ;
 1819                   ;   if the sector number has already been set (BLKNMBR), enter
 1820                   ; at this point.
 1821                   ;
 1822 F2D1  21 FCE5     TRKSEC1:LD      HL,BLKNMBR
 1823 F2D4  4E                  LD      C,(HL)          ;move sector number into (BC).
 1824 F2D5  23                  INC     HL
 1825 F2D6  46                  LD      B,(HL)
 1826 F2D7  2A FCB7             LD      HL,(SCRATCH3)   ;get current sector number and
 1827 F2DA  5E                  LD      E,(HL)          ;move this into (DE).
 1828 F2DB  23                  INC     HL
 1829 F2DC  56                  LD      D,(HL)
 1830 F2DD  2A FCB5             LD      HL,(SCRATCH2)   ;get current track number.
 1831 F2E0  7E                  LD      A,(HL)          ;and this into (HL).
 1832 F2E1  23                  INC     HL
 1833 F2E2  66                  LD      H,(HL)
 1834 F2E3  6F                  LD      L,A
 1835 F2E4  79          TRKSEC2:LD      A,C             ;is desired sector before current one?
 1836 F2E5  93                  SUB     E
 1837 F2E6  78                  LD      A,B
 1838 F2E7  9A                  SBC     A,D
 1839 F2E8  D2 F2FA             JP      NC,TRKSEC3
 1840 F2EB  E5                  PUSH    HL              ;yes, decrement sectors by one track.
 1841 F2EC  2A FCC1             LD      HL,(SECTORS)    ;get sectors per track.
 1842 F2EF  7B                  LD      A,E
 1843 F2F0  95                  SUB     L
 1844 F2F1  5F                  LD      E,A
 1845 F2F2  7A                  LD      A,D
 1846 F2F3  9C                  SBC     A,H
 1847 F2F4  57                  LD      D,A             ;now we have backed up one full track.
 1848 F2F5  E1                  POP     HL
 1849 F2F6  2B                  DEC     HL              ;adjust track counter.
 1850 F2F7  C3 F2E4             JP      TRKSEC2
 1851 F2FA  E5          TRKSEC3:PUSH    HL              ;desired sector is after current one.
 1852 F2FB  2A FCC1             LD      HL,(SECTORS)    ;get sectors per track.
 1853 F2FE  19                  ADD     HL,DE           ;bump sector pointer to next track.
 1854 F2FF  DA F30F             JP      C,TRKSEC4
 1855 F302  79                  LD      A,C             ;is desired sector now before current one?
 1856 F303  95                  SUB     L
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  33
BDOS22  Z80

 1857 F304  78                  LD      A,B
 1858 F305  9C                  SBC     A,H
 1859 F306  DA F30F             JP      C,TRKSEC4
 1860 F309  EB                  EX      DE,HL           ;not yes, increment track counter
 1861 F30A  E1                  POP     HL              ;and continue until it is.
 1862 F30B  23                  INC     HL
 1863 F30C  C3 F2FA             JP      TRKSEC3
 1864                   ;
 1865                   ;   here we have determined the track number that contains the
 1866                   ; desired sector.
 1867                   ;
 1868 F30F  E1          TRKSEC4:POP     HL              ;get track number (HL).
 1869 F310  C5                  PUSH    BC
 1870 F311  D5                  PUSH    DE
 1871 F312  E5                  PUSH    HL
 1872 F313  EB                  EX      DE,HL
 1873 F314  2A FCCE             LD      HL,(OFFSET)     ;adjust for first track offset.
 1874 F317  19                  ADD     HL,DE
 1875 F318  44                  LD      B,H
 1876 F319  4D                  LD      C,L
 1877 F31A  CD FD1E             CALL    SETTRK          ;select this track.
 1878 F31D  D1                  POP     DE              ;reset current track pointer.
 1879 F31E  2A FCB5             LD      HL,(SCRATCH2)
 1880 F321  73                  LD      (HL),E
 1881 F322  23                  INC     HL
 1882 F323  72                  LD      (HL),D
 1883 F324  D1                  POP     DE
 1884 F325  2A FCB7             LD      HL,(SCRATCH3)   ;reset the first sector on this track.
 1885 F328  73                  LD      (HL),E
 1886 F329  23                  INC     HL
 1887 F32A  72                  LD      (HL),D
 1888 F32B  C1                  POP     BC
 1889 F32C  79                  LD      A,C             ;now subtract the desired one.
 1890 F32D  93                  SUB     E               ;to make it relative (1-# sectors/track).
 1891 F32E  4F                  LD      C,A
 1892 F32F  78                  LD      A,B
 1893 F330  9A                  SBC     A,D
 1894 F331  47                  LD      B,A
 1895 F332  2A FCD0             LD      HL,(XLATE)      ;translate this sector according to this table.
 1896 F335  EB                  EX      DE,HL
 1897 F336  CD FD30             CALL    SECTRN          ;let the bios translate it.
 1898 F339  4D                  LD      C,L
 1899 F33A  44                  LD      B,H
 1900 F33B  C3 FD21             JP      SETSEC          ;and select it.
 1901                   ;
 1902                   ;   Compute block number from record number (SAVNREC) and
 1903                   ; extent number (SAVEXT).
 1904                   ;
 1905 F33E  21 FCC3     GETBLOCK: LD    HL,BLKSHFT      ;get logical to physical conversion.
 1906 F341  4E                  LD      C,(HL)          ;note that this is base 2 log of ratio.
 1907 F342  3A FCE3             LD      A,(SAVNREC)     ;get record number.
 1908 F345  B7          GETBLK1:OR      A               ;compute (A)=(A)/2^BLKSHFT.
 1909 F346  1F                  RRA     
 1910 F347  0D                  DEC     C
 1911 F348  C2 F345             JP      NZ,GETBLK1
 1912 F34B  47                  LD      B,A             ;save result in (B).
 1913 F34C  3E 08               LD      A,8
 1914 F34E  96                  SUB     (HL)
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  34
BDOS22  Z80

 1915 F34F  4F                  LD      C,A             ;compute (C)=8-BLKSHFT.
 1916 F350  3A FCE2             LD      A,(SAVEXT)
 1917 F353  0D          GETBLK2:DEC     C               ;compute (A)=SAVEXT*2^(8-BLKSHFT).
 1918 F354  CA F35C             JP      Z,GETBLK3
 1919 F357  B7                  OR      A
 1920 F358  17                  RLA     
 1921 F359  C3 F353             JP      GETBLK2
 1922 F35C  80          GETBLK3:ADD     A,B
 1923 F35D  C9                  RET     
 1924                   ;
 1925                   ;   Routine to extract the (BC) block byte from the fcb pointed
 1926                   ; to by (PARAMS). If this is a big-disk, then these are 16 bit
 1927                   ; block numbers, else they are 8 bit numbers.
 1928                   ; Number is returned in (HL).
 1929                   ;
 1930 F35E  2A F243     EXTBLK: LD      HL,(PARAMS)     ;get fcb address.
 1931 F361  11 0010             LD      DE,16           ;block numbers start 16 bytes into fcb.
 1932 F364  19                  ADD     HL,DE
 1933 F365  09                  ADD     HL,BC
 1934 F366  3A FCDD             LD      A,(BIGDISK)     ;are we using a big-disk?
 1935 F369  B7                  OR      A
 1936 F36A  CA F371             JP      Z,EXTBLK1
 1937 F36D  6E                  LD      L,(HL)          ;no, extract an 8 bit number from the fcb.
 1938 F36E  26 00               LD      H,0
 1939 F370  C9                  RET     
 1940 F371  09          EXTBLK1:ADD     HL,BC           ;yes, extract a 16 bit number.
 1941 F372  5E                  LD      E,(HL)
 1942 F373  23                  INC     HL
 1943 F374  56                  LD      D,(HL)
 1944 F375  EB                  EX      DE,HL           ;return in (HL).
 1945 F376  C9                  RET     
 1946                   ;
 1947                   ;   Compute block number.
 1948                   ;
 1949 F377  CD F33E     COMBLK: CALL    GETBLOCK
 1950 F37A  4F                  LD      C,A
 1951 F37B  06 00               LD      B,0
 1952 F37D  CD F35E             CALL    EXTBLK
 1953 F380  22 FCE5             LD      (BLKNMBR),HL
 1954 F383  C9                  RET     
 1955                   ;
 1956                   ;   Check for a zero block number (unused).
 1957                   ;
 1958 F384  2A FCE5     CHKBLK: LD      HL,(BLKNMBR)
 1959 F387  7D                  LD      A,L             ;is it zero?
 1960 F388  B4                  OR      H
 1961 F389  C9                  RET     
 1962                   ;
 1963                   ;   Adjust physical block (BLKNMBR) and convert to logical
 1964                   ; sector (LOGSECT). This is the starting sector of this block.
 1965                   ; The actual sector of interest is then added to this and the
 1966                   ; resulting sector number is stored back in (BLKNMBR). This
 1967                   ; will still have to be adjusted for the track number.
 1968                   ;
 1969 F38A  3A FCC3     LOGICAL:LD      A,(BLKSHFT)     ;get log2(physical/logical sectors).
 1970 F38D  2A FCE5             LD      HL,(BLKNMBR)    ;get physical sector desired.
 1971 F390  29          LOGICL1:ADD     HL,HL           ;compute logical sector number.
 1972 F391  3D                  DEC     A               ;note logical sectors are 128 bytes long.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  35
BDOS22  Z80

 1973 F392  C2 F390             JP      NZ,LOGICL1
 1974 F395  22 FCE7             LD      (LOGSECT),HL    ;save logical sector.
 1975 F398  3A FCC4             LD      A,(BLKMASK)     ;get block mask.
 1976 F39B  4F                  LD      C,A
 1977 F39C  3A FCE3             LD      A,(SAVNREC)     ;get next sector to access.
 1978 F39F  A1                  AND     C               ;extract the relative position within physical block.
 1979 F3A0  B5                  OR      L               ;and add it too logical sector.
 1980 F3A1  6F                  LD      L,A
 1981 F3A2  22 FCE5             LD      (BLKNMBR),HL    ;and store.
 1982 F3A5  C9                  RET     
 1983                   ;
 1984                   ;   Set (HL) to point to extent byte in fcb.
 1985                   ;
 1986 F3A6  2A F243     SETEXT: LD      HL,(PARAMS)
 1987 F3A9  11 000C             LD      DE,12           ;it is the twelth byte.
 1988 F3AC  19                  ADD     HL,DE
 1989 F3AD  C9                  RET     
 1990                   ;
 1991                   ;   Set (HL) to point to record count byte in fcb and (DE) to
 1992                   ; next record number byte.
 1993                   ;
 1994 F3AE  2A F243     SETHLDE:LD      HL,(PARAMS)
 1995 F3B1  11 000F             LD      DE,15           ;record count byte (#15).
 1996 F3B4  19                  ADD     HL,DE
 1997 F3B5  EB                  EX      DE,HL
 1998 F3B6  21 0011             LD      HL,17           ;next record number (#32).
 1999 F3B9  19                  ADD     HL,DE
 2000 F3BA  C9                  RET     
 2001                   ;
 2002                   ;   Save current file data from fcb.
 2003                   ;
 2004 F3BB  CD F3AE     STRDATA:CALL    SETHLDE
 2005 F3BE  7E                  LD      A,(HL)          ;get and store record count byte.
 2006 F3BF  32 FCE3             LD      (SAVNREC),A
 2007 F3C2  EB                  EX      DE,HL
 2008 F3C3  7E                  LD      A,(HL)          ;get and store next record number byte.
 2009 F3C4  32 FCE1             LD      (SAVNXT),A
 2010 F3C7  CD F3A6             CALL    SETEXT          ;point to extent byte.
 2011 F3CA  3A FCC5             LD      A,(EXTMASK)     ;get extent mask.
 2012 F3CD  A6                  AND     (HL)
 2013 F3CE  32 FCE2             LD      (SAVEXT),A      ;and save extent here.
 2014 F3D1  C9                  RET     
 2015                   ;
 2016                   ;   Set the next record to access. If (MODE) is set to 2, then
 2017                   ; the last record byte (SAVNREC) has the correct number to access.
 2018                   ; For sequential access, (MODE) will be equal to 1.
 2019                   ;
 2020 F3D2  CD F3AE     SETNREC:CALL    SETHLDE
 2021 F3D5  3A FCD5             LD      A,(MODE)        ;get sequential flag (=1).
 2022 F3D8  FE 02               CP      2               ;a 2 indicates that no adder is needed.
 2023 F3DA  C2 F3DE             JP      NZ,STNREC1
 2024 F3DD  AF                  XOR     A               ;clear adder (random access?).
 2025 F3DE  4F          STNREC1:LD      C,A
 2026 F3DF  3A FCE3             LD      A,(SAVNREC)     ;get last record number.
 2027 F3E2  81                  ADD     A,C             ;increment record count.
 2028 F3E3  77                  LD      (HL),A          ;and set fcb's next record byte.
 2029 F3E4  EB                  EX      DE,HL
 2030 F3E5  3A FCE1             LD      A,(SAVNXT)      ;get next record byte from storage.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  36
BDOS22  Z80

 2031 F3E8  77                  LD      (HL),A          ;and put this into fcb as number of records used.
 2032 F3E9  C9                  RET     
 2033                   ;
 2034                   ;   Shift (HL) right (C) bits.
 2035                   ;
 2036 F3EA  0C          SHIFTR: INC     C
 2037 F3EB  0D          SHIFTR1:DEC     C
 2038 F3EC  C8                  RET     Z
 2039 F3ED  7C                  LD      A,H
 2040 F3EE  B7                  OR      A
 2041 F3EF  1F                  RRA     
 2042 F3F0  67                  LD      H,A
 2043 F3F1  7D                  LD      A,L
 2044 F3F2  1F                  RRA     
 2045 F3F3  6F                  LD      L,A
 2046 F3F4  C3 F3EB             JP      SHIFTR1
 2047                   ;
 2048                   ;   Compute the check-sum for the directory buffer. Return
 2049                   ; integer sum in (A).
 2050                   ;
 2051 F3F7  0E 80       CHECKSUM: LD    C,128           ;length of buffer.
 2052 F3F9  2A FCB9             LD      HL,(DIRBUF)     ;get its location.
 2053 F3FC  AF                  XOR     A               ;clear summation byte.
 2054 F3FD  86          CHKSUM1:ADD     A,(HL)          ;and compute sum ignoring carries.
 2055 F3FE  23                  INC     HL
 2056 F3FF  0D                  DEC     C
 2057 F400  C2 F3FD             JP      NZ,CHKSUM1
 2058 F403  C9                  RET     
 2059                   ;
 2060                   ;   Shift (HL) left (C) bits.
 2061                   ;
 2062 F404  0C          SHIFTL: INC     C
 2063 F405  0D          SHIFTL1:DEC     C
 2064 F406  C8                  RET     Z
 2065 F407  29                  ADD     HL,HL           ;shift left 1 bit.
 2066 F408  C3 F405             JP      SHIFTL1
 2067                   ;
 2068                   ;   Routine to set a bit in a 16 bit value contained in (BC).
 2069                   ; The bit set depends on the current drive selection.
 2070                   ;
 2071 F40B  C5          SETBIT: PUSH    BC              ;save 16 bit word.
 2072 F40C  3A F242             LD      A,(ACTIVE)      ;get active drive.
 2073 F40F  4F                  LD      C,A
 2074 F410  21 0001             LD      HL,1
 2075 F413  CD F404             CALL    SHIFTL          ;shift bit 0 into place.
 2076 F416  C1                  POP     BC              ;now 'or' this with the original word.
 2077 F417  79                  LD      A,C
 2078 F418  B5                  OR      L
 2079 F419  6F                  LD      L,A             ;low byte done, do high byte.
 2080 F41A  78                  LD      A,B
 2081 F41B  B4                  OR      H
 2082 F41C  67                  LD      H,A
 2083 F41D  C9                  RET     
 2084                   ;
 2085                   ;   Extract the write protect status bit for the current drive.
 2086                   ; The result is returned in (A), bit 0.
 2087                   ;
 2088 F41E  2A FCAD     GETWPRT:LD      HL,(WRTPRT)     ;get status bytes.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  37
BDOS22  Z80

 2089 F421  3A F242             LD      A,(ACTIVE)      ;which drive is current?
 2090 F424  4F                  LD      C,A
 2091 F425  CD F3EA             CALL    SHIFTR          ;shift status such that bit 0 is the
 2092 F428  7D                  LD      A,L             ;one of interest for this drive.
 2093 F429  E6 01               AND     01H             ;and isolate it.
 2094 F42B  C9                  RET     
 2095                   ;
 2096                   ;   Function to write protect the current disk.
 2097                   ;
 2098 F42C  21 FCAD     WRTPRTD:LD      HL,WRTPRT       ;point to status word.
 2099 F42F  4E                  LD      C,(HL)          ;set (BC) equal to the status.
 2100 F430  23                  INC     HL
 2101 F431  46                  LD      B,(HL)
 2102 F432  CD F40B             CALL    SETBIT          ;and set this bit according to current drive.
 2103 F435  22 FCAD             LD      (WRTPRT),HL     ;then save.
 2104 F438  2A FCC8             LD      HL,(DIRSIZE)    ;now save directory size limit.
 2105 F43B  23                  INC     HL              ;remember the last one.
 2106 F43C  EB                  EX      DE,HL
 2107 F43D  2A FCB3             LD      HL,(SCRATCH1)   ;and store it here.
 2108 F440  73                  LD      (HL),E          ;put low byte.
 2109 F441  23                  INC     HL
 2110 F442  72                  LD      (HL),D          ;then high byte.
 2111 F443  C9                  RET     
 2112                   ;
 2113                   ;   Check for a read only file.
 2114                   ;
 2115 F444  CD F45E     CHKROFL:CALL    FCB2HL          ;set (HL) to file entry in directory buffer.
 2116 F447  11 0009     CKROF1: LD      DE,9            ;look at bit 7 of the ninth byte.
 2117 F44A  19                  ADD     HL,DE
 2118 F44B  7E                  LD      A,(HL)
 2119 F44C  17                  RLA     
 2120 F44D  D0                  RET     NC              ;return if ok.
 2121 F44E  21 EF0F             LD      HL,ROFILE       ;else, print error message and terminate.
 2122 F451  C3 F24A             JP      JUMPHL
 2123                   ;
 2124                   ;   Check the write protect status of the active disk.
 2125                   ;
 2126 F454  CD F41E     CHKWPRT:CALL    GETWPRT
 2127 F457  C8                  RET     Z               ;return if ok.
 2128 F458  21 EF0D             LD      HL,RODISK       ;else print message and terminate.
 2129 F45B  C3 F24A             JP      JUMPHL
 2130                   ;
 2131                   ;   Routine to set (HL) pointing to the proper entry in the
 2132                   ; directory buffer.
 2133                   ;
 2134 F45E  2A FCB9     FCB2HL: LD      HL,(DIRBUF)     ;get address of buffer.
 2135 F461  3A FCE9             LD      A,(FCBPOS)      ;relative position of file.
 2136                   ;
 2137                   ;   Routine to add (A) to (HL).
 2138                   ;
 2139 F464  85          ADDA2HL:ADD     A,L
 2140 F465  6F                  LD      L,A
 2141 F466  D0                  RET     NC
 2142 F467  24                  INC     H               ;take care of any carry.
 2143 F468  C9                  RET     
 2144                   ;
 2145                   ;   Routine to get the 's2' byte from the fcb supplied in
 2146                   ; the initial parameter specification.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  38
BDOS22  Z80

 2147                   ;
 2148 F469  2A F243     GETS2:  LD      HL,(PARAMS)     ;get address of fcb.
 2149 F46C  11 000E             LD      DE,14           ;relative position of 's2'.
 2150 F46F  19                  ADD     HL,DE
 2151 F470  7E                  LD      A,(HL)          ;extract this byte.
 2152 F471  C9                  RET     
 2153                   ;
 2154                   ;   Clear the 's2' byte in the fcb.
 2155                   ;
 2156 F472  CD F469     CLEARS2:CALL    GETS2           ;this sets (HL) pointing to it.
 2157 F475  36 00               LD      (HL),0          ;now clear it.
 2158 F477  C9                  RET     
 2159                   ;
 2160                   ;   Set bit 7 in the 's2' byte of the fcb.
 2161                   ;
 2162 F478  CD F469     SETS2B7:CALL    GETS2           ;get the byte.
 2163 F47B  F6 80               OR      80H             ;and set bit 7.
 2164 F47D  77                  LD      (HL),A          ;then store.
 2165 F47E  C9                  RET     
 2166                   ;
 2167                   ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
 2168                   ; the difference. This checks to see if there are more file
 2169                   ; names in the directory. We are at (FILEPOS) and there are
 2170                   ; (SCRATCH1) of them to check.
 2171                   ;
 2172 F47F  2A FCEA     MOREFLS:LD      HL,(FILEPOS)    ;we are here.
 2173 F482  EB                  EX      DE,HL
 2174 F483  2A FCB3             LD      HL,(SCRATCH1)   ;and don't go past here.
 2175 F486  7B                  LD      A,E             ;compute difference but don't keep.
 2176 F487  96                  SUB     (HL)
 2177 F488  23                  INC     HL
 2178 F489  7A                  LD      A,D
 2179 F48A  9E                  SBC     A,(HL)          ;set carry if no more names.
 2180 F48B  C9                  RET     
 2181                   ;
 2182                   ;   Call this routine to prevent (SCRATCH1) from being greater
 2183                   ; than (FILEPOS).
 2184                   ;
 2185 F48C  CD F47F     CHKNMBR:CALL    MOREFLS         ;SCRATCH1 too big?
 2186 F48F  D8                  RET     C
 2187 F490  13                  INC     DE              ;yes, reset it to (FILEPOS).
 2188 F491  72                  LD      (HL),D
 2189 F492  2B                  DEC     HL
 2190 F493  73                  LD      (HL),E
 2191 F494  C9                  RET     
 2192                   ;
 2193                   ;   Compute (HL)=(DE)-(HL)
 2194                   ;
 2195 F495  7B          SUBHL:  LD      A,E             ;compute difference.
 2196 F496  95                  SUB     L
 2197 F497  6F                  LD      L,A             ;store low byte.
 2198 F498  7A                  LD      A,D
 2199 F499  9C                  SBC     A,H
 2200 F49A  67                  LD      H,A             ;and then high byte.
 2201 F49B  C9                  RET     
 2202                   ;
 2203                   ;   Set the directory checksum byte.
 2204                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  39
BDOS22  Z80

 2205 F49C  0E FF       SETDIR: LD      C,0FFH
 2206                   ;
 2207                   ;   Routine to set or compare the directory checksum byte. If
 2208                   ; (C)=0ffh, then this will set the checksum byte. Else the byte
 2209                   ; will be checked. If the check fails (the disk has been changed),
 2210                   ; then this disk will be write protected.
 2211                   ;
 2212 F49E  2A FCEC     CHECKDIR: LD    HL,(CKSUMTBL)
 2213 F4A1  EB                  EX      DE,HL
 2214 F4A2  2A FCCC             LD      HL,(ALLOC1)
 2215 F4A5  CD F495             CALL    SUBHL
 2216 F4A8  D0                  RET     NC              ;ok if (CKSUMTBL) > (ALLOC1), so return.
 2217 F4A9  C5                  PUSH    BC
 2218 F4AA  CD F3F7             CALL    CHECKSUM        ;else compute checksum.
 2219 F4AD  2A FCBD             LD      HL,(CHKVECT)    ;get address of checksum table.
 2220 F4B0  EB                  EX      DE,HL
 2221 F4B1  2A FCEC             LD      HL,(CKSUMTBL)
 2222 F4B4  19                  ADD     HL,DE           ;set (HL) to point to byte for this drive.
 2223 F4B5  C1                  POP     BC
 2224 F4B6  0C                  INC     C               ;set or check ?
 2225 F4B7  CA F4C4             JP      Z,CHKDIR1
 2226 F4BA  BE                  CP      (HL)            ;check them.
 2227 F4BB  C8                  RET     Z               ;return if they are the same.
 2228 F4BC  CD F47F             CALL    MOREFLS         ;not the same, do we care?
 2229 F4BF  D0                  RET     NC
 2230 F4C0  CD F42C             CALL    WRTPRTD         ;yes, mark this as write protected.
 2231 F4C3  C9                  RET     
 2232 F4C4  77          CHKDIR1:LD      (HL),A          ;just set the byte.
 2233 F4C5  C9                  RET     
 2234                   ;
 2235                   ;   Do a write to the directory of the current disk.
 2236                   ;
 2237 F4C6  CD F49C     DIRWRITE: CALL  SETDIR          ;set checksum byte.
 2238 F4C9  CD F4E0             CALL    DIRDMA          ;set directory dma address.
 2239 F4CC  0E 01               LD      C,1             ;tell the bios to actually write.
 2240 F4CE  CD F2B8             CALL    DOWRITE         ;then do the write.
 2241 F4D1  C3 F4DA             JP      DEFDMA
 2242                   ;
 2243                   ;   Read from the directory.
 2244                   ;
 2245 F4D4  CD F4E0     DIRREAD:CALL    DIRDMA          ;set the directory dma address.
 2246 F4D7  CD F2B2             CALL    DOREAD          ;and read it.
 2247                   ;
 2248                   ;   Routine to set the dma address to the users choice.
 2249                   ;
 2250 F4DA  21 FCB1     DEFDMA: LD      HL,USERDMA      ;reset the default dma address and return.
 2251 F4DD  C3 F4E3             JP      DIRDMA1
 2252                   ;
 2253                   ;   Routine to set the dma address for directory work.
 2254                   ;
 2255 F4E0  21 FCB9     DIRDMA: LD      HL,DIRBUF
 2256                   ;
 2257                   ;   Set the dma address. On entry, (HL) points to
 2258                   ; word containing the desired dma address.
 2259                   ;
 2260 F4E3  4E          DIRDMA1:LD      C,(HL)
 2261 F4E4  23                  INC     HL
 2262 F4E5  46                  LD      B,(HL)          ;setup (BC) and go to the bios to set it.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  40
BDOS22  Z80

 2263 F4E6  C3 FD24             JP      SETDMA
 2264                   ;
 2265                   ;   Move the directory buffer into user's dma space.
 2266                   ;
 2267 F4E9  2A FCB9     MOVEDIR:LD      HL,(DIRBUF)     ;buffer is located here, and
 2268 F4EC  EB                  EX      DE,HL
 2269 F4ED  2A FCB1             LD      HL,(USERDMA)    ; put it here.
 2270 F4F0  0E 80               LD      C,128           ;this is its length.
 2271 F4F2  C3 F24F             JP      DE2HL           ;move it now and return.
 2272                   ;
 2273                   ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
 2274                   ;
 2275 F4F5  21 FCEA     CKFILPOS: LD    HL,FILEPOS
 2276 F4F8  7E                  LD      A,(HL)
 2277 F4F9  23                  INC     HL
 2278 F4FA  BE                  CP      (HL)            ;are both bytes the same?
 2279 F4FB  C0                  RET     NZ
 2280 F4FC  3C                  INC     A               ;yes, but are they each 0ffh?
 2281 F4FD  C9                  RET     
 2282                   ;
 2283                   ;   Set location (FILEPOS) to 0ffffh.
 2284                   ;
 2285 F4FE  21 FFFF     STFILPOS: LD    HL,0FFFFH
 2286 F501  22 FCEA             LD      (FILEPOS),HL
 2287 F504  C9                  RET     
 2288                   ;
 2289                   ;   Move on to the next file position within the current
 2290                   ; directory buffer. If no more exist, set pointer to 0ffffh
 2291                   ; and the calling routine will check for this. Enter with (C)
 2292                   ; equal to 0ffh to cause the checksum byte to be set, else we
 2293                   ; will check this disk and set write protect if checksums are
 2294                   ; not the same (applies only if another directory sector must
 2295                   ; be read).
 2296                   ;
 2297 F505  2A FCC8     NXENTRY:LD      HL,(DIRSIZE)    ;get directory entry size limit.
 2298 F508  EB                  EX      DE,HL
 2299 F509  2A FCEA             LD      HL,(FILEPOS)    ;get current count.
 2300 F50C  23                  INC     HL              ;go on to the next one.
 2301 F50D  22 FCEA             LD      (FILEPOS),HL
 2302 F510  CD F495             CALL    SUBHL           ;(HL)=(DIRSIZE)-(FILEPOS)
 2303 F513  D2 F519             JP      NC,NXENT1       ;is there more room left?
 2304 F516  C3 F4FE             JP      STFILPOS        ;no. Set this flag and return.
 2305 F519  3A FCEA     NXENT1: LD      A,(FILEPOS)     ;get file position within directory.
 2306 F51C  E6 03               AND     03H             ;only look within this sector (only 4 entries fit).
 2307 F51E  06 05               LD      B,5             ;convert to relative position (32 bytes each).
 2308 F520  87          NXENT2: ADD     A,A             ;note that this is not efficient code.
 2309 F521  05                  DEC     B               ;5 'ADD A's would be better.
 2310 F522  C2 F520             JP      NZ,NXENT2
 2311 F525  32 FCE9             LD      (FCBPOS),A      ;save it as position of fcb.
 2312 F528  B7                  OR      A
 2313 F529  C0                  RET     NZ              ;return if we are within buffer.
 2314 F52A  C5                  PUSH    BC
 2315 F52B  CD F2C3             CALL    TRKSEC          ;we need the next directory sector.
 2316 F52E  CD F4D4             CALL    DIRREAD
 2317 F531  C1                  POP     BC
 2318 F532  C3 F49E             JP      CHECKDIR
 2319                   ;
 2320                   ;   Routine to to get a bit from the disk space allocation
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  41
BDOS22  Z80

 2321                   ; map. It is returned in (A), bit position 0. On entry to here,
 2322                   ; set (BC) to the block number on the disk to check.
 2323                   ; On return, (D) will contain the original bit position for
 2324                   ; this block number and (HL) will point to the address for it.
 2325                   ;
 2326 F535  79          CKBITMAP: LD    A,C             ;determine bit number of interest.
 2327 F536  E6 07               AND     07H             ;compute (D)=(E)=(C and 7)+1.
 2328 F538  3C                  INC     A
 2329 F539  5F                  LD      E,A             ;save particular bit number.
 2330 F53A  57                  LD      D,A
 2331                   ;
 2332                   ;   compute (BC)=(BC)/8.
 2333                   ;
 2334 F53B  79                  LD      A,C
 2335 F53C  0F                  RRCA                    ;now shift right 3 bits.
 2336 F53D  0F                  RRCA    
 2337 F53E  0F                  RRCA    
 2338 F53F  E6 1F               AND     1FH             ;and clear bits 7,6,5.
 2339 F541  4F                  LD      C,A
 2340 F542  78                  LD      A,B
 2341 F543  87                  ADD     A,A             ;now shift (B) into bits 7,6,5.
 2342 F544  87                  ADD     A,A
 2343 F545  87                  ADD     A,A
 2344 F546  87                  ADD     A,A
 2345 F547  87                  ADD     A,A
 2346 F548  B1                  OR      C               ;and add in (C).
 2347 F549  4F                  LD      C,A             ;ok, (C) ha been completed.
 2348 F54A  78                  LD      A,B             ;is there a better way of doing this?
 2349 F54B  0F                  RRCA    
 2350 F54C  0F                  RRCA    
 2351 F54D  0F                  RRCA    
 2352 F54E  E6 1F               AND     1FH
 2353 F550  47                  LD      B,A             ;and now (B) is completed.
 2354                   ;
 2355                   ;   use this as an offset into the disk space allocation
 2356                   ; table.
 2357                   ;
 2358 F551  2A FCBF             LD      HL,(ALOCVECT)
 2359 F554  09                  ADD     HL,BC
 2360 F555  7E                  LD      A,(HL)          ;now get correct byte.
 2361 F556  07          CKBMAP1:RLCA                    ;get correct bit into position 0.
 2362 F557  1D                  DEC     E
 2363 F558  C2 F556             JP      NZ,CKBMAP1
 2364 F55B  C9                  RET     
 2365                   ;
 2366                   ;   Set or clear the bit map such that block number (BC) will be marked
 2367                   ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
 2368                   ; 1 then it will be set (don't use anyother values).
 2369                   ;
 2370 F55C  D5          STBITMAP: PUSH  DE
 2371 F55D  CD F535             CALL    CKBITMAP        ;get the byte of interest.
 2372 F560  E6 FE               AND     0FEH            ;clear the affected bit.
 2373 F562  C1                  POP     BC
 2374 F563  B1                  OR      C               ;and now set it acording to (C).
 2375                   ;
 2376                   ;  entry to restore the original bit position and then store
 2377                   ; in table. (A) contains the value, (D) contains the bit
 2378                   ; position (1-8), and (HL) points to the address within the
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  42
BDOS22  Z80

 2379                   ; space allocation table for this byte.
 2380                   ;
 2381 F564  0F          STBMAP1:RRCA                    ;restore original bit position.
 2382 F565  15                  DEC     D
 2383 F566  C2 F564             JP      NZ,STBMAP1
 2384 F569  77                  LD      (HL),A          ;and stor byte in table.
 2385 F56A  C9                  RET     
 2386                   ;
 2387                   ;   Set/clear space used bits in allocation map for this file.
 2388                   ; On entry, (C)=1 to set the map and (C)=0 to clear it.
 2389                   ;
 2390 F56B  CD F45E     SETFILE:CALL    FCB2HL          ;get address of fcb
 2391 F56E  11 0010             LD      DE,16
 2392 F571  19                  ADD     HL,DE           ;get to block number bytes.
 2393 F572  C5                  PUSH    BC
 2394 F573  0E 11               LD      C,17            ;check all 17 bytes (max) of table.
 2395 F575  D1          SETFL1: POP     DE
 2396 F576  0D                  DEC     C               ;done all bytes yet?
 2397 F577  C8                  RET     Z
 2398 F578  D5                  PUSH    DE
 2399 F579  3A FCDD             LD      A,(BIGDISK)     ;check disk size for 16 bit block numbers.
 2400 F57C  B7                  OR      A
 2401 F57D  CA F588             JP      Z,SETFL2
 2402 F580  C5                  PUSH    BC              ;only 8 bit numbers. set (BC) to this one.
 2403 F581  E5                  PUSH    HL
 2404 F582  4E                  LD      C,(HL)          ;get low byte from table, always
 2405 F583  06 00               LD      B,0             ;set high byte to zero.
 2406 F585  C3 F58E             JP      SETFL3
 2407 F588  0D          SETFL2: DEC     C               ;for 16 bit block numbers, adjust counter.
 2408 F589  C5                  PUSH    BC
 2409 F58A  4E                  LD      C,(HL)          ;now get both the low and high bytes.
 2410 F58B  23                  INC     HL
 2411 F58C  46                  LD      B,(HL)
 2412 F58D  E5                  PUSH    HL
 2413 F58E  79          SETFL3: LD      A,C             ;block used?
 2414 F58F  B0                  OR      B
 2415 F590  CA F59D             JP      Z,SETFL4
 2416 F593  2A FCC6             LD      HL,(DSKSIZE)    ;is this block number within the
 2417 F596  7D                  LD      A,L             ;space on the disk?
 2418 F597  91                  SUB     C
 2419 F598  7C                  LD      A,H
 2420 F599  98                  SBC     A,B
 2421 F59A  D4 F55C             CALL    NC,STBITMAP     ;yes, set the proper bit.
 2422 F59D  E1          SETFL4: POP     HL              ;point to next block number in fcb.
 2423 F59E  23                  INC     HL
 2424 F59F  C1                  POP     BC
 2425 F5A0  C3 F575             JP      SETFL1
 2426                   ;
 2427                   ;   Construct the space used allocation bit map for the active
 2428                   ; drive. If a file name starts with '$' and it is under the
 2429                   ; current user number, then (STATUS) is set to minus 1. Otherwise
 2430                   ; it is not set at all.
 2431                   ;
 2432 F5A3  2A FCC6     BITMAP: LD      HL,(DSKSIZE)    ;compute size of allocation table.
 2433 F5A6  0E 03               LD      C,3
 2434 F5A8  CD F3EA             CALL    SHIFTR          ;(HL)=(HL)/8.
 2435 F5AB  23                  INC     HL              ;at lease 1 byte.
 2436 F5AC  44                  LD      B,H
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  43
BDOS22  Z80

 2437 F5AD  4D                  LD      C,L             ;set (BC) to the allocation table length.
 2438                   ;
 2439                   ;   Initialize the bitmap for this drive. Right now, the first
 2440                   ; two bytes are specified by the disk parameter block. However
 2441                   ; a patch could be entered here if it were necessary to setup
 2442                   ; this table in a special mannor. For example, the bios could
 2443                   ; determine locations of 'bad blocks' and set them as already
 2444                   ; 'used' in the map.
 2445                   ;
 2446 F5AE  2A FCBF             LD      HL,(ALOCVECT)   ;now zero out the table now.
 2447 F5B1  36 00       BITMAP1:LD      (HL),0
 2448 F5B3  23                  INC     HL
 2449 F5B4  0B                  DEC     BC
 2450 F5B5  78                  LD      A,B
 2451 F5B6  B1                  OR      C
 2452 F5B7  C2 F5B1             JP      NZ,BITMAP1
 2453 F5BA  2A FCCA             LD      HL,(ALLOC0)     ;get initial space used by directory.
 2454 F5BD  EB                  EX      DE,HL
 2455 F5BE  2A FCBF             LD      HL,(ALOCVECT)   ;and put this into map.
 2456 F5C1  73                  LD      (HL),E
 2457 F5C2  23                  INC     HL
 2458 F5C3  72                  LD      (HL),D
 2459                   ;
 2460                   ;   End of initialization portion.
 2461                   ;
 2462 F5C4  CD F2A1             CALL    HOMEDRV         ;now home the drive.
 2463 F5C7  2A FCB3             LD      HL,(SCRATCH1)
 2464 F5CA  36 03               LD      (HL),3          ;force next directory request to read
 2465 F5CC  23                  INC     HL              ;in a sector.
 2466 F5CD  36 00               LD      (HL),0
 2467 F5CF  CD F4FE             CALL    STFILPOS        ;clear initial file position also.
 2468 F5D2  0E FF       BITMAP2:LD      C,0FFH          ;read next file name in directory
 2469 F5D4  CD F505             CALL    NXENTRY         ;and set checksum byte.
 2470 F5D7  CD F4F5             CALL    CKFILPOS        ;is there another file?
 2471 F5DA  C8                  RET     Z
 2472 F5DB  CD F45E             CALL    FCB2HL          ;yes, get its address.
 2473 F5DE  3E E5               LD      A,0E5H
 2474 F5E0  BE                  CP      (HL)            ;empty file entry?
 2475 F5E1  CA F5D2             JP      Z,BITMAP2
 2476 F5E4  3A F241             LD      A,(USERNO)      ;no, correct user number?
 2477 F5E7  BE                  CP      (HL)
 2478 F5E8  C2 F5F6             JP      NZ,BITMAP3
 2479 F5EB  23                  INC     HL
 2480 F5EC  7E                  LD      A,(HL)          ;yes, does name start with a '$'?
 2481 F5ED  D6 24               SUB     '$'
 2482 F5EF  C2 F5F6             JP      NZ,BITMAP3
 2483 F5F2  3D                  DEC     A               ;yes, set atatus to minus one.
 2484 F5F3  32 F245             LD      (STATUS),A
 2485 F5F6  0E 01       BITMAP3:LD      C,1             ;now set this file's space as used in bit map.
 2486 F5F8  CD F56B             CALL    SETFILE
 2487 F5FB  CD F48C             CALL    CHKNMBR         ;keep (SCRATCH1) in bounds.
 2488 F5FE  C3 F5D2             JP      BITMAP2
 2489                   ;
 2490                   ;   Set the status (STATUS) and return.
 2491                   ;
 2492 F601  3A FCD4     STSTATUS: LD    A,(FNDSTAT)
 2493 F604  C3 F201             JP      SETSTAT
 2494                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  44
BDOS22  Z80

 2495                   ;   Check extents in (A) and (C). Set the zero flag if they
 2496                   ; are the same. The number of 16k chunks of disk space that
 2497                   ; the directory extent covers is expressad is (EXTMASK+1).
 2498                   ; No registers are modified.
 2499                   ;
 2500 F607  C5          SAMEXT: PUSH    BC
 2501 F608  F5                  PUSH    AF
 2502 F609  3A FCC5             LD      A,(EXTMASK)     ;get extent mask and use it to
 2503 F60C  2F                  CPL                     ;to compare both extent numbers.
 2504 F60D  47                  LD      B,A             ;save resulting mask here.
 2505 F60E  79                  LD      A,C             ;mask first extent and save in (C).
 2506 F60F  A0                  AND     B
 2507 F610  4F                  LD      C,A
 2508 F611  F1                  POP     AF              ;now mask second extent and compare
 2509 F612  A0                  AND     B               ;with the first one.
 2510 F613  91                  SUB     C
 2511 F614  E6 1F               AND     1FH             ;(* only check buts 0-4 *)
 2512 F616  C1                  POP     BC              ;the zero flag is set if they are the same.
 2513 F617  C9                  RET                     ;restore (BC) and return.
 2514                   ;
 2515                   ;   Search for the first occurence of a file name. On entry,
 2516                   ; register (C) should contain the number of bytes of the fcb
 2517                   ; that must match.
 2518                   ;
 2519 F618  3E FF       FINDFST:LD      A,0FFH
 2520 F61A  32 FCD4             LD      (FNDSTAT),A
 2521 F61D  21 FCD8             LD      HL,COUNTER      ;save character count.
 2522 F620  71                  LD      (HL),C
 2523 F621  2A F243             LD      HL,(PARAMS)     ;get filename to match.
 2524 F624  22 FCD9             LD      (SAVEFCB),HL    ;and save.
 2525 F627  CD F4FE             CALL    STFILPOS        ;clear initial file position (set to 0ffffh).
 2526 F62A  CD F2A1             CALL    HOMEDRV         ;home the drive.
 2527                   ;
 2528                   ;   Entry to locate the next occurence of a filename within the
 2529                   ; directory. The disk is not expected to have been changed. If
 2530                   ; it was, then it will be write protected.
 2531                   ;
 2532 F62D  0E 00       FINDNXT:LD      C,0             ;write protect the disk if changed.
 2533 F62F  CD F505             CALL    NXENTRY         ;get next filename entry in directory.
 2534 F632  CD F4F5             CALL    CKFILPOS        ;is file position = 0ffffh?
 2535 F635  CA F694             JP      Z,FNDNXT6       ;yes, exit now then.
 2536 F638  2A FCD9             LD      HL,(SAVEFCB)    ;set (DE) pointing to filename to match.
 2537 F63B  EB                  EX      DE,HL
 2538 F63C  1A                  LD      A,(DE)
 2539 F63D  FE E5               CP      0E5H            ;empty directory entry?
 2540 F63F  CA F64A             JP      Z,FNDNXT1       ;(* are we trying to reserect erased entries? *)
 2541 F642  D5                  PUSH    DE
 2542 F643  CD F47F             CALL    MOREFLS         ;more files in directory?
 2543 F646  D1                  POP     DE
 2544 F647  D2 F694             JP      NC,FNDNXT6      ;no more. Exit now.
 2545 F64A  CD F45E     FNDNXT1:CALL    FCB2HL          ;get address of this fcb in directory.
 2546 F64D  3A FCD8             LD      A,(COUNTER)     ;get number of bytes (characters) to check.
 2547 F650  4F                  LD      C,A
 2548 F651  06 00               LD      B,0             ;initialize byte position counter.
 2549 F653  79          FNDNXT2:LD      A,C             ;are we done with the compare?
 2550 F654  B7                  OR      A
 2551 F655  CA F683             JP      Z,FNDNXT5
 2552 F658  1A                  LD      A,(DE)          ;no, check next byte.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  45
BDOS22  Z80

 2553 F659  FE 3F               CP      '?'             ;don't care about this character?
 2554 F65B  CA F67C             JP      Z,FNDNXT4
 2555 F65E  78                  LD      A,B             ;get bytes position in fcb.
 2556 F65F  FE 0D               CP      13              ;don't care about the thirteenth byte either.
 2557 F661  CA F67C             JP      Z,FNDNXT4
 2558 F664  FE 0C               CP      12              ;extent byte?
 2559 F666  1A                  LD      A,(DE)
 2560 F667  CA F673             JP      Z,FNDNXT3
 2561 F66A  96                  SUB     (HL)            ;otherwise compare characters.
 2562 F66B  E6 7F               AND     7FH
 2563 F66D  C2 F62D             JP      NZ,FINDNXT      ;not the same, check next entry.
 2564 F670  C3 F67C             JP      FNDNXT4         ;so far so good, keep checking.
 2565 F673  C5          FNDNXT3:PUSH    BC              ;check the extent byte here.
 2566 F674  4E                  LD      C,(HL)
 2567 F675  CD F607             CALL    SAMEXT
 2568 F678  C1                  POP     BC
 2569 F679  C2 F62D             JP      NZ,FINDNXT      ;not the same, look some more.
 2570                   ;
 2571                   ;   So far the names compare. Bump pointers to the next byte
 2572                   ; and continue until all (C) characters have been checked.
 2573                   ;
 2574 F67C  13          FNDNXT4:INC     DE              ;bump pointers.
 2575 F67D  23                  INC     HL
 2576 F67E  04                  INC     B
 2577 F67F  0D                  DEC     C               ;adjust character counter.
 2578 F680  C3 F653             JP      FNDNXT2
 2579 F683  3A FCEA     FNDNXT5:LD      A,(FILEPOS)     ;return the position of this entry.
 2580 F686  E6 03               AND     03H
 2581 F688  32 F245             LD      (STATUS),A
 2582 F68B  21 FCD4             LD      HL,FNDSTAT
 2583 F68E  7E                  LD      A,(HL)
 2584 F68F  17                  RLA     
 2585 F690  D0                  RET     NC
 2586 F691  AF                  XOR     A
 2587 F692  77                  LD      (HL),A
 2588 F693  C9                  RET     
 2589                   ;
 2590                   ;   Filename was not found. Set appropriate status.
 2591                   ;
 2592 F694  CD F4FE     FNDNXT6:CALL    STFILPOS        ;set (FILEPOS) to 0ffffh.
 2593 F697  3E FF               LD      A,0FFH          ;say not located.
 2594 F699  C3 F201             JP      SETSTAT
 2595                   ;
 2596                   ;   Erase files from the directory. Only the first byte of the
 2597                   ; fcb will be affected. It is set to (E5).
 2598                   ;
 2599 F69C  CD F454     ERAFILE:CALL    CHKWPRT         ;is disk write protected?
 2600 F69F  0E 0C               LD      C,12            ;only compare file names.
 2601 F6A1  CD F618             CALL    FINDFST         ;get first file name.
 2602 F6A4  CD F4F5     ERAFIL1:CALL    CKFILPOS        ;any found?
 2603 F6A7  C8                  RET     Z               ;nope, we must be done.
 2604 F6A8  CD F444             CALL    CHKROFL         ;is file read only?
 2605 F6AB  CD F45E             CALL    FCB2HL          ;nope, get address of fcb and
 2606 F6AE  36 E5               LD      (HL),0E5H       ;set first byte to 'empty'.
 2607 F6B0  0E 00               LD      C,0             ;clear the space from the bit map.
 2608 F6B2  CD F56B             CALL    SETFILE
 2609 F6B5  CD F4C6             CALL    DIRWRITE        ;now write the directory sector back out.
 2610 F6B8  CD F62D             CALL    FINDNXT         ;find the next file name.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  46
BDOS22  Z80

 2611 F6BB  C3 F6A4             JP      ERAFIL1         ;and repeat process.
 2612                   ;
 2613                   ;   Look through the space allocation map (bit map) for the
 2614                   ; next available block. Start searching at block number (BC-1).
 2615                   ; The search procedure is to look for an empty block that is
 2616                   ; before the starting block. If not empty, look at a later
 2617                   ; block number. In this way, we return the closest empty block
 2618                   ; on either side of the 'target' block number. This will speed
 2619                   ; access on random devices. For serial devices, this should be
 2620                   ; changed to look in the forward direction first and then start
 2621                   ; at the front and search some more.
 2622                   ;
 2623                   ;   On return, (DE)= block number that is empty and (HL) =0
 2624                   ; if no empry block was found.
 2625                   ;
 2626 F6BE  50          FNDSPACE: LD    D,B             ;set (DE) as the block that is checked.
 2627 F6BF  59                  LD      E,C
 2628                   ;
 2629                   ;   Look before target block. Registers (BC) are used as the lower
 2630                   ; pointer and (DE) as the upper pointer.
 2631                   ;
 2632 F6C0  79          FNDSPA1:LD      A,C             ;is block 0 specified?
 2633 F6C1  B0                  OR      B
 2634 F6C2  CA F6D1             JP      Z,FNDSPA2
 2635 F6C5  0B                  DEC     BC              ;nope, check previous block.
 2636 F6C6  D5                  PUSH    DE
 2637 F6C7  C5                  PUSH    BC
 2638 F6C8  CD F535             CALL    CKBITMAP
 2639 F6CB  1F                  RRA                     ;is this block empty?
 2640 F6CC  D2 F6EC             JP      NC,FNDSPA3      ;yes. use this.
 2641                   ;
 2642                   ;   Note that the above logic gets the first block that it finds
 2643                   ; that is empty. Thus a file could be written 'backward' making
 2644                   ; it very slow to access. This could be changed to look for the
 2645                   ; first empty block and then continue until the start of this
 2646                   ; empty space is located and then used that starting block.
 2647                   ; This should help speed up access to some files especially on
 2648                   ; a well used disk with lots of fairly small 'holes'.
 2649                   ;
 2650 F6CF  C1                  POP     BC              ;nope, check some more.
 2651 F6D0  D1                  POP     DE
 2652                   ;
 2653                   ;   Now look after target block.
 2654                   ;
 2655 F6D1  2A FCC6     FNDSPA2:LD      HL,(DSKSIZE)    ;is block (DE) within disk limits?
 2656 F6D4  7B                  LD      A,E
 2657 F6D5  95                  SUB     L
 2658 F6D6  7A                  LD      A,D
 2659 F6D7  9C                  SBC     A,H
 2660 F6D8  D2 F6F4             JP      NC,FNDSPA4
 2661 F6DB  13                  INC     DE              ;yes, move on to next one.
 2662 F6DC  C5                  PUSH    BC
 2663 F6DD  D5                  PUSH    DE
 2664 F6DE  42                  LD      B,D
 2665 F6DF  4B                  LD      C,E
 2666 F6E0  CD F535             CALL    CKBITMAP        ;check it.
 2667 F6E3  1F                  RRA                     ;empty?
 2668 F6E4  D2 F6EC             JP      NC,FNDSPA3
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  47
BDOS22  Z80

 2669 F6E7  D1                  POP     DE              ;nope, continue searching.
 2670 F6E8  C1                  POP     BC
 2671 F6E9  C3 F6C0             JP      FNDSPA1
 2672                   ;
 2673                   ;   Empty block found. Set it as used and return with (HL)
 2674                   ; pointing to it (true?).
 2675                   ;
 2676 F6EC  17          FNDSPA3:RLA                     ;reset byte.
 2677 F6ED  3C                  INC     A               ;and set bit 0.
 2678 F6EE  CD F564             CALL    STBMAP1         ;update bit map.
 2679 F6F1  E1                  POP     HL              ;set return registers.
 2680 F6F2  D1                  POP     DE
 2681 F6F3  C9                  RET     
 2682                   ;
 2683                   ;   Free block was not found. If (BC) is not zero, then we have
 2684                   ; not checked all of the disk space.
 2685                   ;
 2686 F6F4  79          FNDSPA4:LD      A,C
 2687 F6F5  B0                  OR      B
 2688 F6F6  C2 F6C0             JP      NZ,FNDSPA1
 2689 F6F9  21 0000             LD      HL,0            ;set 'not found' status.
 2690 F6FC  C9                  RET     
 2691                   ;
 2692                   ;   Move a complete fcb entry into the directory and write it.
 2693                   ;
 2694 F6FD  0E 00       FCBSET: LD      C,0
 2695 F6FF  1E 20               LD      E,32            ;length of each entry.
 2696                   ;
 2697                   ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
 2698                   ; fcb in directory starting at relative byte (C). This updated
 2699                   ; directory buffer is then written to the disk.
 2700                   ;
 2701 F701  D5          UPDATE: PUSH    DE
 2702 F702  06 00               LD      B,0             ;set (BC) to relative byte position.
 2703 F704  2A F243             LD      HL,(PARAMS)     ;get address of fcb.
 2704 F707  09                  ADD     HL,BC           ;compute starting byte.
 2705 F708  EB                  EX      DE,HL
 2706 F709  CD F45E             CALL    FCB2HL          ;get address of fcb to update in directory.
 2707 F70C  C1                  POP     BC              ;set (C) to number of bytes to change.
 2708 F70D  CD F24F             CALL    DE2HL
 2709 F710  CD F2C3     UPDATE1:CALL    TRKSEC          ;determine the track and sector affected.
 2710 F713  C3 F4C6             JP      DIRWRITE        ;then write this sector out.
 2711                   ;
 2712                   ;   Routine to change the name of all files on the disk with a
 2713                   ; specified name. The fcb contains the current name as the
 2714                   ; first 12 characters and the new name 16 bytes into the fcb.
 2715                   ;
 2716 F716  CD F454     CHGNAMES: CALL  CHKWPRT         ;check for a write protected disk.
 2717 F719  0E 0C               LD      C,12            ;match first 12 bytes of fcb only.
 2718 F71B  CD F618             CALL    FINDFST         ;get first name.
 2719 F71E  2A F243             LD      HL,(PARAMS)     ;get address of fcb.
 2720 F721  7E                  LD      A,(HL)          ;get user number.
 2721 F722  11 0010             LD      DE,16           ;move over to desired name.
 2722 F725  19                  ADD     HL,DE
 2723 F726  77                  LD      (HL),A          ;keep same user number.
 2724 F727  CD F4F5     CHGNAM1:CALL    CKFILPOS        ;any matching file found?
 2725 F72A  C8                  RET     Z               ;no, we must be done.
 2726 F72B  CD F444             CALL    CHKROFL         ;check for read only file.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  48
BDOS22  Z80

 2727 F72E  0E 10               LD      C,16            ;start 16 bytes into fcb.
 2728 F730  1E 0C               LD      E,12            ;and update the first 12 bytes of directory.
 2729 F732  CD F701             CALL    UPDATE
 2730 F735  CD F62D             CALL    FINDNXT         ;get te next file name.
 2731 F738  C3 F727             JP      CHGNAM1         ;and continue.
 2732                   ;
 2733                   ;   Update a files attributes. The procedure is to search for
 2734                   ; every file with the same name as shown in fcb (ignoring bit 7)
 2735                   ; and then to update it (which includes bit 7). No other changes
 2736                   ; are made.
 2737                   ;
 2738 F73B  0E 0C       SAVEATTR: LD    C,12            ;match first 12 bytes.
 2739 F73D  CD F618             CALL    FINDFST         ;look for first filename.
 2740 F740  CD F4F5     SAVATR1:CALL    CKFILPOS        ;was one found?
 2741 F743  C8                  RET     Z               ;nope, we must be done.
 2742 F744  0E 00               LD      C,0             ;yes, update the first 12 bytes now.
 2743 F746  1E 0C               LD      E,12
 2744 F748  CD F701             CALL    UPDATE          ;update filename and write directory.
 2745 F74B  CD F62D             CALL    FINDNXT         ;and get the next file.
 2746 F74E  C3 F740             JP      SAVATR1         ;then continue until done.
 2747                   ;
 2748                   ;  Open a file (name specified in fcb).
 2749                   ;
 2750 F751  0E 0F       OPENIT: LD      C,15            ;compare the first 15 bytes.
 2751 F753  CD F618             CALL    FINDFST         ;get the first one in directory.
 2752 F756  CD F4F5             CALL    CKFILPOS        ;any at all?
 2753 F759  C8                  RET     Z
 2754 F75A  CD F3A6     OPENIT1:CALL    SETEXT          ;point to extent byte within users fcb.
 2755 F75D  7E                  LD      A,(HL)          ;and get it.
 2756 F75E  F5                  PUSH    AF              ;save it and address.
 2757 F75F  E5                  PUSH    HL
 2758 F760  CD F45E             CALL    FCB2HL          ;point to fcb in directory.
 2759 F763  EB                  EX      DE,HL
 2760 F764  2A F243             LD      HL,(PARAMS)     ;this is the users copy.
 2761 F767  0E 20               LD      C,32            ;move it into users space.
 2762 F769  D5                  PUSH    DE
 2763 F76A  CD F24F             CALL    DE2HL
 2764 F76D  CD F478             CALL    SETS2B7         ;set bit 7 in 's2' byte (unmodified).
 2765 F770  D1                  POP     DE              ;now get the extent byte from this fcb.
 2766 F771  21 000C             LD      HL,12
 2767 F774  19                  ADD     HL,DE
 2768 F775  4E                  LD      C,(HL)          ;into (C).
 2769 F776  21 000F             LD      HL,15           ;now get the record count byte into (B).
 2770 F779  19                  ADD     HL,DE
 2771 F77A  46                  LD      B,(HL)
 2772 F77B  E1                  POP     HL              ;keep the same extent as the user had originally.
 2773 F77C  F1                  POP     AF
 2774 F77D  77                  LD      (HL),A
 2775 F77E  79                  LD      A,C             ;is it the same as in the directory fcb?
 2776 F77F  BE                  CP      (HL)
 2777 F780  78                  LD      A,B             ;if yes, then use the same record count.
 2778 F781  CA F78B             JP      Z,OPENIT2
 2779 F784  3E 00               LD      A,0             ;if the user specified an extent greater than
 2780 F786  DA F78B             JP      C,OPENIT2       ;the one in the directory, then set record count to 0.
 2781 F789  3E 80               LD      A,128           ;otherwise set to maximum.
 2782 F78B  2A F243     OPENIT2:LD      HL,(PARAMS)     ;set record count in users fcb to (A).
 2783 F78E  11 000F             LD      DE,15
 2784 F791  19                  ADD     HL,DE           ;compute relative position.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  49
BDOS22  Z80

 2785 F792  77                  LD      (HL),A          ;and set the record count.
 2786 F793  C9                  RET     
 2787                   ;
 2788                   ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
 2789                   ; point to a zero value (16 bit).
 2790                   ;   Return with zero flag set it (DE) was moved. Registers (DE)
 2791                   ; and (HL) are not changed. However (A) is.
 2792                   ;
 2793 F794  7E          MOVEWORD: LD    A,(HL)          ;check for a zero word.
 2794 F795  23                  INC     HL
 2795 F796  B6                  OR      (HL)            ;both bytes zero?
 2796 F797  2B                  DEC     HL
 2797 F798  C0                  RET     NZ              ;nope, just return.
 2798 F799  1A                  LD      A,(DE)          ;yes, move two bytes from (DE) into
 2799 F79A  77                  LD      (HL),A          ;this zero space.
 2800 F79B  13                  INC     DE
 2801 F79C  23                  INC     HL
 2802 F79D  1A                  LD      A,(DE)
 2803 F79E  77                  LD      (HL),A
 2804 F79F  1B                  DEC     DE              ;don't disturb these registers.
 2805 F7A0  2B                  DEC     HL
 2806 F7A1  C9                  RET     
 2807                   ;
 2808                   ;   Get here to close a file specified by (fcb).
 2809                   ;
 2810 F7A2  AF          CLOSEIT:XOR     A               ;clear status and file position bytes.
 2811 F7A3  32 F245             LD      (STATUS),A
 2812 F7A6  32 FCEA             LD      (FILEPOS),A
 2813 F7A9  32 FCEB             LD      (FILEPOS+1),A
 2814 F7AC  CD F41E             CALL    GETWPRT         ;get write protect bit for this drive.
 2815 F7AF  C0                  RET     NZ              ;just return if it is set.
 2816 F7B0  CD F469             CALL    GETS2           ;else get the 's2' byte.
 2817 F7B3  E6 80               AND     80H             ;and look at bit 7 (file unmodified?).
 2818 F7B5  C0                  RET     NZ              ;just return if set.
 2819 F7B6  0E 0F               LD      C,15            ;else look up this file in directory.
 2820 F7B8  CD F618             CALL    FINDFST
 2821 F7BB  CD F4F5             CALL    CKFILPOS        ;was it found?
 2822 F7BE  C8                  RET     Z               ;just return if not.
 2823 F7BF  01 0010             LD      BC,16           ;set (HL) pointing to records used section.
 2824 F7C2  CD F45E             CALL    FCB2HL
 2825 F7C5  09                  ADD     HL,BC
 2826 F7C6  EB                  EX      DE,HL
 2827 F7C7  2A F243             LD      HL,(PARAMS)     ;do the same for users specified fcb.
 2828 F7CA  09                  ADD     HL,BC
 2829 F7CB  0E 10               LD      C,16            ;this many bytes are present in this extent.
 2830 F7CD  3A FCDD     CLOSEIT1: LD    A,(BIGDISK)     ;8 or 16 bit record numbers?
 2831 F7D0  B7                  OR      A
 2832 F7D1  CA F7E8             JP      Z,CLOSEIT4
 2833 F7D4  7E                  LD      A,(HL)          ;just 8 bit. Get one from users fcb.
 2834 F7D5  B7                  OR      A
 2835 F7D6  1A                  LD      A,(DE)          ;now get one from directory fcb.
 2836 F7D7  C2 F7DB             JP      NZ,CLOSEIT2
 2837 F7DA  77                  LD      (HL),A          ;users byte was zero. Update from directory.
 2838 F7DB  B7          CLOSEIT2: OR    A
 2839 F7DC  C2 F7E1             JP      NZ,CLOSEIT3
 2840 F7DF  7E                  LD      A,(HL)          ;directories byte was zero, update from users fcb.
 2841 F7E0  12                  LD      (DE),A
 2842 F7E1  BE          CLOSEIT3: CP    (HL)            ;if neither one of these bytes were zero,
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  50
BDOS22  Z80

 2843 F7E2  C2 F81F             JP      NZ,CLOSEIT7     ;then close error if they are not the same.
 2844 F7E5  C3 F7FD             JP      CLOSEIT5        ;ok so far, get to next byte in fcbs.
 2845 F7E8  CD F794     CLOSEIT4: CALL  MOVEWORD        ;update users fcb if it is zero.
 2846 F7EB  EB                  EX      DE,HL
 2847 F7EC  CD F794             CALL    MOVEWORD        ;update directories fcb if it is zero.
 2848 F7EF  EB                  EX      DE,HL
 2849 F7F0  1A                  LD      A,(DE)          ;if these two values are no different,
 2850 F7F1  BE                  CP      (HL)            ;then a close error occured.
 2851 F7F2  C2 F81F             JP      NZ,CLOSEIT7
 2852 F7F5  13                  INC     DE              ;check second byte.
 2853 F7F6  23                  INC     HL
 2854 F7F7  1A                  LD      A,(DE)
 2855 F7F8  BE                  CP      (HL)
 2856 F7F9  C2 F81F             JP      NZ,CLOSEIT7
 2857 F7FC  0D                  DEC     C               ;remember 16 bit values.
 2858 F7FD  13          CLOSEIT5: INC   DE              ;bump to next item in table.
 2859 F7FE  23                  INC     HL
 2860 F7FF  0D                  DEC     C               ;there are 16 entries only.
 2861 F800  C2 F7CD             JP      NZ,CLOSEIT1     ;continue if more to do.
 2862 F803  01 FFEC             LD      BC,0FFECH       ;backup 20 places (extent byte).
 2863 F806  09                  ADD     HL,BC
 2864 F807  EB                  EX      DE,HL
 2865 F808  09                  ADD     HL,BC
 2866 F809  1A                  LD      A,(DE)
 2867 F80A  BE                  CP      (HL)            ;directory's extent already greater than the
 2868 F80B  DA F817             JP      C,CLOSEIT6      ;users extent?
 2869 F80E  77                  LD      (HL),A          ;no, update directory extent.
 2870 F80F  01 0003             LD      BC,3            ;and update the record count byte in
 2871 F812  09                  ADD     HL,BC           ;directories fcb.
 2872 F813  EB                  EX      DE,HL
 2873 F814  09                  ADD     HL,BC
 2874 F815  7E                  LD      A,(HL)          ;get from user.
 2875 F816  12                  LD      (DE),A          ;and put in directory.
 2876 F817  3E FF       CLOSEIT6: LD    A,0FFH          ;set 'was open and is now closed' byte.
 2877 F819  32 FCD2             LD      (CLOSEFLG),A
 2878 F81C  C3 F710             JP      UPDATE1         ;update the directory now.
 2879 F81F  21 F245     CLOSEIT7: LD    HL,STATUS       ;set return status and then return.
 2880 F822  35                  DEC     (HL)
 2881 F823  C9                  RET     
 2882                   ;
 2883                   ;   Routine to get the next empty space in the directory. It
 2884                   ; will then be cleared for use.
 2885                   ;
 2886 F824  CD F454     GETEMPTY: CALL  CHKWPRT         ;make sure disk is not write protected.
 2887 F827  2A F243             LD      HL,(PARAMS)     ;save current parameters (fcb).
 2888 F82A  E5                  PUSH    HL
 2889 F82B  21 FCAC             LD      HL,EMPTYFCB     ;use special one for empty space.
 2890 F82E  22 F243             LD      (PARAMS),HL
 2891 F831  0E 01               LD      C,1             ;search for first empty spot in directory.
 2892 F833  CD F618             CALL    FINDFST         ;(* only check first byte *)
 2893 F836  CD F4F5             CALL    CKFILPOS        ;none?
 2894 F839  E1                  POP     HL
 2895 F83A  22 F243             LD      (PARAMS),HL     ;restore original fcb address.
 2896 F83D  C8                  RET     Z               ;return if no more space.
 2897 F83E  EB                  EX      DE,HL
 2898 F83F  21 000F             LD      HL,15           ;point to number of records for this file.
 2899 F842  19                  ADD     HL,DE
 2900 F843  0E 11               LD      C,17            ;and clear all of this space.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  51
BDOS22  Z80

 2901 F845  AF                  XOR     A
 2902 F846  77          GETMT1: LD      (HL),A
 2903 F847  23                  INC     HL
 2904 F848  0D                  DEC     C
 2905 F849  C2 F846             JP      NZ,GETMT1
 2906 F84C  21 000D             LD      HL,13           ;clear the 's1' byte also.
 2907 F84F  19                  ADD     HL,DE
 2908 F850  77                  LD      (HL),A
 2909 F851  CD F48C             CALL    CHKNMBR         ;keep (SCRATCH1) within bounds.
 2910 F854  CD F6FD             CALL    FCBSET          ;write out this fcb entry to directory.
 2911 F857  C3 F478             JP      SETS2B7         ;set 's2' byte bit 7 (unmodified at present).
 2912                   ;
 2913                   ;   Routine to close the current extent and open the next one
 2914                   ; for reading.
 2915                   ;
 2916 F85A  AF          GETNEXT:XOR     A
 2917 F85B  32 FCD2             LD      (CLOSEFLG),A    ;clear close flag.
 2918 F85E  CD F7A2             CALL    CLOSEIT         ;close this extent.
 2919 F861  CD F4F5             CALL    CKFILPOS
 2920 F864  C8                  RET     Z               ;not there???
 2921 F865  2A F243             LD      HL,(PARAMS)     ;get extent byte.
 2922 F868  01 000C             LD      BC,12
 2923 F86B  09                  ADD     HL,BC
 2924 F86C  7E                  LD      A,(HL)          ;and increment it.
 2925 F86D  3C                  INC     A
 2926 F86E  E6 1F               AND     1FH             ;keep within range 0-31.
 2927 F870  77                  LD      (HL),A
 2928 F871  CA F883             JP      Z,GTNEXT1       ;overflow?
 2929 F874  47                  LD      B,A             ;mask extent byte.
 2930 F875  3A FCC5             LD      A,(EXTMASK)
 2931 F878  A0                  AND     B
 2932 F879  21 FCD2             LD      HL,CLOSEFLG     ;check close flag (0ffh is ok).
 2933 F87C  A6                  AND     (HL)
 2934 F87D  CA F88E             JP      Z,GTNEXT2       ;if zero, we must read in next extent.
 2935 F880  C3 F8AC             JP      GTNEXT3         ;else, it is already in memory.
 2936 F883  01 0002     GTNEXT1:LD      BC,2            ;Point to the 's2' byte.
 2937 F886  09                  ADD     HL,BC
 2938 F887  34                  INC     (HL)            ;and bump it.
 2939 F888  7E                  LD      A,(HL)          ;too many extents?
 2940 F889  E6 0F               AND     0FH
 2941 F88B  CA F8B6             JP      Z,GTNEXT5       ;yes, set error code.
 2942                   ;
 2943                   ;   Get here to open the next extent.
 2944                   ;
 2945 F88E  0E 0F       GTNEXT2:LD      C,15            ;set to check first 15 bytes of fcb.
 2946 F890  CD F618             CALL    FINDFST         ;find the first one.
 2947 F893  CD F4F5             CALL    CKFILPOS        ;none available?
 2948 F896  C2 F8AC             JP      NZ,GTNEXT3
 2949 F899  3A FCD3             LD      A,(RDWRTFLG)    ;no extent present. Can we open an empty one?
 2950 F89C  3C                  INC     A               ;0ffh means reading (so not possible).
 2951 F89D  CA F8B6             JP      Z,GTNEXT5       ;or an error.
 2952 F8A0  CD F824             CALL    GETEMPTY        ;we are writing, get an empty entry.
 2953 F8A3  CD F4F5             CALL    CKFILPOS        ;none?
 2954 F8A6  CA F8B6             JP      Z,GTNEXT5       ;error if true.
 2955 F8A9  C3 F8AF             JP      GTNEXT4         ;else we are almost done.
 2956 F8AC  CD F75A     GTNEXT3:CALL    OPENIT1         ;open this extent.
 2957 F8AF  CD F3BB     GTNEXT4:CALL    STRDATA         ;move in updated data (rec #, extent #, etc.)
 2958 F8B2  AF                  XOR     A               ;clear status and return.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  52
BDOS22  Z80

 2959 F8B3  C3 F201             JP      SETSTAT
 2960                   ;
 2961                   ;   Error in extending the file. Too many extents were needed
 2962                   ; or not enough space on the disk.
 2963                   ;
 2964 F8B6  CD F205     GTNEXT5:CALL    IOERR1          ;set error code, clear bit 7 of 's2'
 2965 F8B9  C3 F478             JP      SETS2B7         ;so this is not written on a close.
 2966                   ;
 2967                   ;   Read a sequential file.
 2968                   ;
 2969 F8BC  3E 01       RDSEQ:  LD      A,1             ;set sequential access mode.
 2970 F8BE  32 FCD5             LD      (MODE),A
 2971 F8C1  3E FF       RDSEQ1: LD      A,0FFH          ;don't allow reading unwritten space.
 2972 F8C3  32 FCD3             LD      (RDWRTFLG),A
 2973 F8C6  CD F3BB             CALL    STRDATA         ;put rec# and ext# into fcb.
 2974 F8C9  3A FCE3             LD      A,(SAVNREC)     ;get next record to read.
 2975 F8CC  21 FCE1             LD      HL,SAVNXT       ;get number of records in extent.
 2976 F8CF  BE                  CP      (HL)            ;within this extent?
 2977 F8D0  DA F8E6             JP      C,RDSEQ2
 2978 F8D3  FE 80               CP      128             ;no. Is this extent fully used?
 2979 F8D5  C2 F8FB             JP      NZ,RDSEQ3       ;no. End-of-file.
 2980 F8D8  CD F85A             CALL    GETNEXT         ;yes, open the next one.
 2981 F8DB  AF                  XOR     A               ;reset next record to read.
 2982 F8DC  32 FCE3             LD      (SAVNREC),A
 2983 F8DF  3A F245             LD      A,(STATUS)      ;check on open, successful?
 2984 F8E2  B7                  OR      A
 2985 F8E3  C2 F8FB             JP      NZ,RDSEQ3       ;no, error.
 2986 F8E6  CD F377     RDSEQ2: CALL    COMBLK          ;ok. compute block number to read.
 2987 F8E9  CD F384             CALL    CHKBLK          ;check it. Within bounds?
 2988 F8EC  CA F8FB             JP      Z,RDSEQ3        ;no, error.
 2989 F8EF  CD F38A             CALL    LOGICAL         ;convert (BLKNMBR) to logical sector (128 byte).
 2990 F8F2  CD F2D1             CALL    TRKSEC1         ;set the track and sector for this block #.
 2991 F8F5  CD F2B2             CALL    DOREAD          ;and read it.
 2992 F8F8  C3 F3D2             JP      SETNREC         ;and set the next record to be accessed.
 2993                   ;
 2994                   ;   Read error occured. Set status and return.
 2995                   ;
 2996 F8FB  C3 F205     RDSEQ3: JP      IOERR1
 2997                   ;
 2998                   ;   Write the next sequential record.
 2999                   ;
 3000 F8FE  3E 01       WTSEQ:  LD      A,1             ;set sequential access mode.
 3001 F900  32 FCD5             LD      (MODE),A
 3002 F903  3E 00       WTSEQ1: LD      A,0             ;allow an addition empty extent to be opened.
 3003 F905  32 FCD3             LD      (RDWRTFLG),A
 3004 F908  CD F454             CALL    CHKWPRT         ;check write protect status.
 3005 F90B  2A F243             LD      HL,(PARAMS)
 3006 F90E  CD F447             CALL    CKROF1          ;check for read only file, (HL) already set to fcb.
 3007 F911  CD F3BB             CALL    STRDATA         ;put updated data into fcb.
 3008 F914  3A FCE3             LD      A,(SAVNREC)     ;get record number to write.
 3009 F917  FE 80               CP      128             ;within range?
 3010 F919  D2 F205             JP      NC,IOERR1       ;no, error(?).
 3011 F91C  CD F377             CALL    COMBLK          ;compute block number.
 3012 F91F  CD F384             CALL    CHKBLK          ;check number.
 3013 F922  0E 00               LD      C,0             ;is there one to write to?
 3014 F924  C2 F96E             JP      NZ,WTSEQ6       ;yes, go do it.
 3015 F927  CD F33E             CALL    GETBLOCK        ;get next block number within fcb to use.
 3016 F92A  32 FCD7             LD      (RELBLOCK),A    ;and save.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  53
BDOS22  Z80

 3017 F92D  01 0000             LD      BC,0            ;start looking for space from the start
 3018 F930  B7                  OR      A               ;if none allocated as yet.
 3019 F931  CA F93B             JP      Z,WTSEQ2
 3020 F934  4F                  LD      C,A             ;extract previous block number from fcb
 3021 F935  0B                  DEC     BC              ;so we can be closest to it.
 3022 F936  CD F35E             CALL    EXTBLK
 3023 F939  44                  LD      B,H
 3024 F93A  4D                  LD      C,L
 3025 F93B  CD F6BE     WTSEQ2: CALL    FNDSPACE        ;find the next empty block nearest number (BC).
 3026 F93E  7D                  LD      A,L             ;check for a zero number.
 3027 F93F  B4                  OR      H
 3028 F940  C2 F948             JP      NZ,WTSEQ3
 3029 F943  3E 02               LD      A,2             ;no more space?
 3030 F945  C3 F201             JP      SETSTAT
 3031 F948  22 FCE5     WTSEQ3: LD      (BLKNMBR),HL    ;save block number to access.
 3032 F94B  EB                  EX      DE,HL           ;put block number into (DE).
 3033 F94C  2A F243             LD      HL,(PARAMS)     ;now we must update the fcb for this
 3034 F94F  01 0010             LD      BC,16           ;newly allocated block.
 3035 F952  09                  ADD     HL,BC
 3036 F953  3A FCDD             LD      A,(BIGDISK)     ;8 or 16 bit block numbers?
 3037 F956  B7                  OR      A
 3038 F957  3A FCD7             LD      A,(RELBLOCK)    ;(* update this entry *)
 3039 F95A  CA F964             JP      Z,WTSEQ4        ;zero means 16 bit ones.
 3040 F95D  CD F464             CALL    ADDA2HL         ;(HL)=(HL)+(A)
 3041 F960  73                  LD      (HL),E          ;store new block number.
 3042 F961  C3 F96C             JP      WTSEQ5
 3043 F964  4F          WTSEQ4: LD      C,A             ;compute spot in this 16 bit table.
 3044 F965  06 00               LD      B,0
 3045 F967  09                  ADD     HL,BC
 3046 F968  09                  ADD     HL,BC
 3047 F969  73                  LD      (HL),E          ;stuff block number (DE) there.
 3048 F96A  23                  INC     HL
 3049 F96B  72                  LD      (HL),D
 3050 F96C  0E 02       WTSEQ5: LD      C,2             ;set (C) to indicate writing to un-used disk space.
 3051 F96E  3A F245     WTSEQ6: LD      A,(STATUS)      ;are we ok so far?
 3052 F971  B7                  OR      A
 3053 F972  C0                  RET     NZ
 3054 F973  C5                  PUSH    BC              ;yes, save write flag for bios (register C).
 3055 F974  CD F38A             CALL    LOGICAL         ;convert (BLKNMBR) over to loical sectors.
 3056 F977  3A FCD5             LD      A,(MODE)        ;get access mode flag (1=sequential,
 3057 F97A  3D                  DEC     A               ;0=random, 2=special?).
 3058 F97B  3D                  DEC     A
 3059 F97C  C2 F9BB             JP      NZ,WTSEQ9
 3060                   ;
 3061                   ;   Special random i/o from function #40. Maybe for M/PM, but the
 3062                   ; current block, if it has not been written to, will be zeroed
 3063                   ; out and then written (reason?).
 3064                   ;
 3065 F97F  C1                  POP     BC
 3066 F980  C5                  PUSH    BC
 3067 F981  79                  LD      A,C             ;get write status flag (2=writing unused space).
 3068 F982  3D                  DEC     A
 3069 F983  3D                  DEC     A
 3070 F984  C2 F9BB             JP      NZ,WTSEQ9
 3071 F987  E5                  PUSH    HL
 3072 F988  2A FCB9             LD      HL,(DIRBUF)     ;zero out the directory buffer.
 3073 F98B  57                  LD      D,A             ;note that (A) is zero here.
 3074 F98C  77          WTSEQ7: LD      (HL),A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  54
BDOS22  Z80

 3075 F98D  23                  INC     HL
 3076 F98E  14                  INC     D               ;do 128 bytes.
 3077 F98F  F2 F98C             JP      P,WTSEQ7
 3078 F992  CD F4E0             CALL    DIRDMA          ;tell the bios the dma address for directory access.
 3079 F995  2A FCE7             LD      HL,(LOGSECT)    ;get sector that starts current block.
 3080 F998  0E 02               LD      C,2             ;set 'writing to unused space' flag.
 3081 F99A  22 FCE5     WTSEQ8: LD      (BLKNMBR),HL    ;save sector to write.
 3082 F99D  C5                  PUSH    BC
 3083 F99E  CD F2D1             CALL    TRKSEC1         ;determine its track and sector numbers.
 3084 F9A1  C1                  POP     BC
 3085 F9A2  CD F2B8             CALL    DOWRITE         ;now write out 128 bytes of zeros.
 3086 F9A5  2A FCE5             LD      HL,(BLKNMBR)    ;get sector number.
 3087 F9A8  0E 00               LD      C,0             ;set normal write flag.
 3088 F9AA  3A FCC4             LD      A,(BLKMASK)     ;determine if we have written the entire
 3089 F9AD  47                  LD      B,A             ;physical block.
 3090 F9AE  A5                  AND     L
 3091 F9AF  B8                  CP      B
 3092 F9B0  23                  INC     HL              ;prepare for the next one.
 3093 F9B1  C2 F99A             JP      NZ,WTSEQ8       ;continue until (BLKMASK+1) sectors written.
 3094 F9B4  E1                  POP     HL              ;reset next sector number.
 3095 F9B5  22 FCE5             LD      (BLKNMBR),HL
 3096 F9B8  CD F4DA             CALL    DEFDMA          ;and reset dma address.
 3097                   ;
 3098                   ;   Normal disk write. Set the desired track and sector then
 3099                   ; do the actual write.
 3100                   ;
 3101 F9BB  CD F2D1     WTSEQ9: CALL    TRKSEC1         ;determine track and sector for this write.
 3102 F9BE  C1                  POP     BC              ;get write status flag.
 3103 F9BF  C5                  PUSH    BC
 3104 F9C0  CD F2B8             CALL    DOWRITE         ;and write this out.
 3105 F9C3  C1                  POP     BC
 3106 F9C4  3A FCE3             LD      A,(SAVNREC)     ;get number of records in file.
 3107 F9C7  21 FCE1             LD      HL,SAVNXT       ;get last record written.
 3108 F9CA  BE                  CP      (HL)
 3109 F9CB  DA F9D2             JP      C,WTSEQ10
 3110 F9CE  77                  LD      (HL),A          ;we have to update record count.
 3111 F9CF  34                  INC     (HL)
 3112 F9D0  0E 02               LD      C,2
 3113                   ;
 3114                   ;*   This area has been patched to correct disk update problem
 3115                   ;* when using blocking and de-blocking in the BIOS.
 3116                   ;
 3117 F9D2  00          WTSEQ10:NOP                     ;was 'dcr c'
 3118 F9D3  00                  NOP                     ;was 'dcr c'
 3119 F9D4  21 0000             LD      HL,0            ;was 'jnz wtseq99'
 3120                   ;
 3121                   ; *   End of patch.
 3122                   ;
 3123 F9D7  F5                  PUSH    AF
 3124 F9D8  CD F469             CALL    GETS2           ;set 'extent written to' flag.
 3125 F9DB  E6 7F               AND     7FH             ;(* clear bit 7 *)
 3126 F9DD  77                  LD      (HL),A
 3127 F9DE  F1                  POP     AF              ;get record count for this extent.
 3128 F9DF  FE 7F       WTSEQ99:CP      127             ;is it full?
 3129 F9E1  C2 FA00             JP      NZ,WTSEQ12
 3130 F9E4  3A FCD5             LD      A,(MODE)        ;yes, are we in sequential mode?
 3131 F9E7  FE 01               CP      1
 3132 F9E9  C2 FA00             JP      NZ,WTSEQ12
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  55
BDOS22  Z80

 3133 F9EC  CD F3D2             CALL    SETNREC         ;yes, set next record number.
 3134 F9EF  CD F85A             CALL    GETNEXT         ;and get next empty space in directory.
 3135 F9F2  21 F245             LD      HL,STATUS       ;ok?
 3136 F9F5  7E                  LD      A,(HL)
 3137 F9F6  B7                  OR      A
 3138 F9F7  C2 F9FE             JP      NZ,WTSEQ11
 3139 F9FA  3D                  DEC     A               ;yes, set record count to -1.
 3140 F9FB  32 FCE3             LD      (SAVNREC),A
 3141 F9FE  36 00       WTSEQ11:LD      (HL),0          ;clear status.
 3142 FA00  C3 F3D2     WTSEQ12:JP      SETNREC         ;set next record to access.
 3143                   ;
 3144                   ;   For random i/o, set the fcb for the desired record number
 3145                   ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
 3146                   ; used as follows:
 3147                   ;
 3148                   ;       fcb+35            fcb+34            fcb+33
 3149                   ;  |     'r-2'      |      'r-1'      |      'r-0'     |
 3150                   ;  |7             0 | 7             0 | 7             0|
 3151                   ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
 3152                   ;  |    overflow   | | extra |  extent   |   record #  |
 3153                   ;  | ______________| |_extent|__number___|_____________|
 3154                   ;                     also 's2'
 3155                   ;
 3156                   ;   On entry, register (C) contains 0ffh if this is a read
 3157                   ; and thus we can not access unwritten disk space. Otherwise,
 3158                   ; another extent will be opened (for writing) if required.
 3159                   ;
 3160 FA03  AF          POSITION: XOR   A               ;set random i/o flag.
 3161 FA04  32 FCD5             LD      (MODE),A
 3162                   ;
 3163                   ;   Special entry (function #40). M/PM ?
 3164                   ;
 3165 FA07  C5          POSITN1:PUSH    BC              ;save read/write flag.
 3166 FA08  2A F243             LD      HL,(PARAMS)     ;get address of fcb.
 3167 FA0B  EB                  EX      DE,HL
 3168 FA0C  21 0021             LD      HL,33           ;now get byte 'r0'.
 3169 FA0F  19                  ADD     HL,DE
 3170 FA10  7E                  LD      A,(HL)
 3171 FA11  E6 7F               AND     7FH             ;keep bits 0-6 for the record number to access.
 3172 FA13  F5                  PUSH    AF
 3173 FA14  7E                  LD      A,(HL)          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
 3174 FA15  17                  RLA     
 3175 FA16  23                  INC     HL
 3176 FA17  7E                  LD      A,(HL)
 3177 FA18  17                  RLA     
 3178 FA19  E6 1F               AND     1FH             ;and save this in bits 0-4 of (C).
 3179 FA1B  4F                  LD      C,A             ;this is the extent byte.
 3180 FA1C  7E                  LD      A,(HL)          ;now get the extra extent byte.
 3181 FA1D  1F                  RRA     
 3182 FA1E  1F                  RRA     
 3183 FA1F  1F                  RRA     
 3184 FA20  1F                  RRA     
 3185 FA21  E6 0F               AND     0FH
 3186 FA23  47                  LD      B,A             ;and save it in (B).
 3187 FA24  F1                  POP     AF              ;get record number back to (A).
 3188 FA25  23                  INC     HL              ;check overflow byte 'r2'.
 3189 FA26  6E                  LD      L,(HL)
 3190 FA27  2C                  INC     L
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  56
BDOS22  Z80

 3191 FA28  2D                  DEC     L
 3192 FA29  2E 06               LD      L,6             ;prepare for error.
 3193 FA2B  C2 FA8B             JP      NZ,POSITN5      ;out of disk space error.
 3194 FA2E  21 0020             LD      HL,32           ;store record number into fcb.
 3195 FA31  19                  ADD     HL,DE
 3196 FA32  77                  LD      (HL),A
 3197 FA33  21 000C             LD      HL,12           ;and now check the extent byte.
 3198 FA36  19                  ADD     HL,DE
 3199 FA37  79                  LD      A,C
 3200 FA38  96                  SUB     (HL)            ;same extent as before?
 3201 FA39  C2 FA47             JP      NZ,POSITN2
 3202 FA3C  21 000E             LD      HL,14           ;yes, check extra extent byte 's2' also.
 3203 FA3F  19                  ADD     HL,DE
 3204 FA40  78                  LD      A,B
 3205 FA41  96                  SUB     (HL)
 3206 FA42  E6 7F               AND     7FH
 3207 FA44  CA FA7F             JP      Z,POSITN3       ;same, we are almost done then.
 3208                   ;
 3209                   ;  Get here when another extent is required.
 3210                   ;
 3211 FA47  C5          POSITN2:PUSH    BC
 3212 FA48  D5                  PUSH    DE
 3213 FA49  CD F7A2             CALL    CLOSEIT         ;close current extent.
 3214 FA4C  D1                  POP     DE
 3215 FA4D  C1                  POP     BC
 3216 FA4E  2E 03               LD      L,3             ;prepare for error.
 3217 FA50  3A F245             LD      A,(STATUS)
 3218 FA53  3C                  INC     A
 3219 FA54  CA FA84             JP      Z,POSITN4       ;close error.
 3220 FA57  21 000C             LD      HL,12           ;put desired extent into fcb now.
 3221 FA5A  19                  ADD     HL,DE
 3222 FA5B  71                  LD      (HL),C
 3223 FA5C  21 000E             LD      HL,14           ;and store extra extent byte 's2'.
 3224 FA5F  19                  ADD     HL,DE
 3225 FA60  70                  LD      (HL),B
 3226 FA61  CD F751             CALL    OPENIT          ;try and get this extent.
 3227 FA64  3A F245             LD      A,(STATUS)      ;was it there?
 3228 FA67  3C                  INC     A
 3229 FA68  C2 FA7F             JP      NZ,POSITN3
 3230 FA6B  C1                  POP     BC              ;no. can we create a new one (writing?).
 3231 FA6C  C5                  PUSH    BC
 3232 FA6D  2E 04               LD      L,4             ;prepare for error.
 3233 FA6F  0C                  INC     C
 3234 FA70  CA FA84             JP      Z,POSITN4       ;nope, reading unwritten space error.
 3235 FA73  CD F824             CALL    GETEMPTY        ;yes we can, try to find space.
 3236 FA76  2E 05               LD      L,5             ;prepare for error.
 3237 FA78  3A F245             LD      A,(STATUS)
 3238 FA7B  3C                  INC     A
 3239 FA7C  CA FA84             JP      Z,POSITN4       ;out of space?
 3240                   ;
 3241                   ;   Normal return location. Clear error code and return.
 3242                   ;
 3243 FA7F  C1          POSITN3:POP     BC              ;restore stack.
 3244 FA80  AF                  XOR     A               ;and clear error code byte.
 3245 FA81  C3 F201             JP      SETSTAT
 3246                   ;
 3247                   ;   Error. Set the 's2' byte to indicate this (why?).
 3248                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  57
BDOS22  Z80

 3249 FA84  E5          POSITN4:PUSH    HL
 3250 FA85  CD F469             CALL    GETS2
 3251 FA88  36 C0               LD      (HL),0C0H
 3252 FA8A  E1                  POP     HL
 3253                   ;
 3254                   ;   Return with error code (presently in L).
 3255                   ;
 3256 FA8B  C1          POSITN5:POP     BC
 3257 FA8C  7D                  LD      A,L             ;get error code.
 3258 FA8D  32 F245             LD      (STATUS),A
 3259 FA90  C3 F478             JP      SETS2B7
 3260                   ;
 3261                   ;   Read a random record.
 3262                   ;
 3263 FA93  0E FF       READRAN:LD      C,0FFH          ;set 'read' status.
 3264 FA95  CD FA03             CALL    POSITION        ;position the file to proper record.
 3265 FA98  CC F8C1             CALL    Z,RDSEQ1        ;and read it as usual (if no errors).
 3266 FA9B  C9                  RET     
 3267                   ;
 3268                   ;   Write to a random record.
 3269                   ;
 3270 FA9C  0E 00       WRITERAN: LD    C,0             ;set 'writing' flag.
 3271 FA9E  CD FA03             CALL    POSITION        ;position the file to proper record.
 3272 FAA1  CC F903             CALL    Z,WTSEQ1        ;and write as usual (if no errors).
 3273 FAA4  C9                  RET     
 3274                   ;
 3275                   ;   Compute the random record number. Enter with (HL) pointing
 3276                   ; to a fcb an (DE) contains a relative location of a record
 3277                   ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
 3278                   ; byte, and (A) the 'r2' byte.
 3279                   ;
 3280                   ;   On return, the zero flag is set if the record is within
 3281                   ; bounds. Otherwise, an overflow occured.
 3282                   ;
 3283 FAA5  EB          COMPRAND: EX    DE,HL           ;save fcb pointer in (DE).
 3284 FAA6  19                  ADD     HL,DE           ;compute relative position of record #.
 3285 FAA7  4E                  LD      C,(HL)          ;get record number into (BC).
 3286 FAA8  06 00               LD      B,0
 3287 FAAA  21 000C             LD      HL,12           ;now get extent.
 3288 FAAD  19                  ADD     HL,DE
 3289 FAAE  7E                  LD      A,(HL)          ;compute (BC)=(record #)+(extent)*128.
 3290 FAAF  0F                  RRCA                    ;move lower bit into bit 7.
 3291 FAB0  E6 80               AND     80H             ;and ignore all other bits.
 3292 FAB2  81                  ADD     A,C             ;add to our record number.
 3293 FAB3  4F                  LD      C,A
 3294 FAB4  3E 00               LD      A,0             ;take care of any carry.
 3295 FAB6  88                  ADC     A,B
 3296 FAB7  47                  LD      B,A
 3297 FAB8  7E                  LD      A,(HL)          ;now get the upper bits of extent into
 3298 FAB9  0F                  RRCA                    ;bit positions 0-3.
 3299 FABA  E6 0F               AND     0FH             ;and ignore all others.
 3300 FABC  80                  ADD     A,B             ;add this in to 'r1' byte.
 3301 FABD  47                  LD      B,A
 3302 FABE  21 000E             LD      HL,14           ;get the 's2' byte (extra extent).
 3303 FAC1  19                  ADD     HL,DE
 3304 FAC2  7E                  LD      A,(HL)
 3305 FAC3  87                  ADD     A,A             ;and shift it left 4 bits (bits 4-7).
 3306 FAC4  87                  ADD     A,A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  58
BDOS22  Z80

 3307 FAC5  87                  ADD     A,A
 3308 FAC6  87                  ADD     A,A
 3309 FAC7  F5                  PUSH    AF              ;save carry flag (bit 0 of flag byte).
 3310 FAC8  80                  ADD     A,B             ;now add extra extent into 'r1'.
 3311 FAC9  47                  LD      B,A
 3312 FACA  F5                  PUSH    AF              ;and save carry (overflow byte 'r2').
 3313 FACB  E1                  POP     HL              ;bit 0 of (L) is the overflow indicator.
 3314 FACC  7D                  LD      A,L
 3315 FACD  E1                  POP     HL              ;and same for first carry flag.
 3316 FACE  B5                  OR      L               ;either one of these set?
 3317 FACF  E6 01               AND     01H             ;only check the carry flags.
 3318 FAD1  C9                  RET     
 3319                   ;
 3320                   ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
 3321                   ; reflect the last record used for a random (or other) file.
 3322                   ; This reads the directory and looks at all extents computing
 3323                   ; the largerst record number for each and keeping the maximum
 3324                   ; value only. Then 'r0', 'r1', and 'r2' will reflect this
 3325                   ; maximum record number. This is used to compute the space used
 3326                   ; by a random file.
 3327                   ;
 3328 FAD2  0E 0C       RANSIZE:LD      C,12            ;look thru directory for first entry with
 3329 FAD4  CD F618             CALL    FINDFST         ;this name.
 3330 FAD7  2A F243             LD      HL,(PARAMS)     ;zero out the 'r0, r1, r2' bytes.
 3331 FADA  11 0021             LD      DE,33
 3332 FADD  19                  ADD     HL,DE
 3333 FADE  E5                  PUSH    HL
 3334 FADF  72                  LD      (HL),D          ;note that (D)=0.
 3335 FAE0  23                  INC     HL
 3336 FAE1  72                  LD      (HL),D
 3337 FAE2  23                  INC     HL
 3338 FAE3  72                  LD      (HL),D
 3339 FAE4  CD F4F5     RANSIZ1:CALL    CKFILPOS        ;is there an extent to process?
 3340 FAE7  CA FB0C             JP      Z,RANSIZ3       ;no, we are done.
 3341 FAEA  CD F45E             CALL    FCB2HL          ;set (HL) pointing to proper fcb in dir.
 3342 FAED  11 000F             LD      DE,15           ;point to last record in extent.
 3343 FAF0  CD FAA5             CALL    COMPRAND        ;and compute random parameters.
 3344 FAF3  E1                  POP     HL
 3345 FAF4  E5                  PUSH    HL              ;now check these values against those
 3346 FAF5  5F                  LD      E,A             ;already in fcb.
 3347 FAF6  79                  LD      A,C             ;the carry flag will be set if those
 3348 FAF7  96                  SUB     (HL)            ;in the fcb represent a larger size than
 3349 FAF8  23                  INC     HL              ;this extent does.
 3350 FAF9  78                  LD      A,B
 3351 FAFA  9E                  SBC     A,(HL)
 3352 FAFB  23                  INC     HL
 3353 FAFC  7B                  LD      A,E
 3354 FAFD  9E                  SBC     A,(HL)
 3355 FAFE  DA FB06             JP      C,RANSIZ2
 3356 FB01  73                  LD      (HL),E          ;we found a larger (in size) extent.
 3357 FB02  2B                  DEC     HL              ;stuff these values into fcb.
 3358 FB03  70                  LD      (HL),B
 3359 FB04  2B                  DEC     HL
 3360 FB05  71                  LD      (HL),C
 3361 FB06  CD F62D     RANSIZ2:CALL    FINDNXT         ;now get the next extent.
 3362 FB09  C3 FAE4             JP      RANSIZ1         ;continue til all done.
 3363 FB0C  E1          RANSIZ3:POP     HL              ;we are done, restore the stack and
 3364 FB0D  C9                  RET                     ;return.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  59
BDOS22  Z80

 3365                   ;
 3366                   ;   Function to return the random record position of a given
 3367                   ; file which has been read in sequential mode up to now.
 3368                   ;
 3369 FB0E  2A F243     SETRAN: LD      HL,(PARAMS)     ;point to fcb.
 3370 FB11  11 0020             LD      DE,32           ;and to last used record.
 3371 FB14  CD FAA5             CALL    COMPRAND        ;compute random position.
 3372 FB17  21 0021             LD      HL,33           ;now stuff these values into fcb.
 3373 FB1A  19                  ADD     HL,DE
 3374 FB1B  71                  LD      (HL),C          ;move 'r0'.
 3375 FB1C  23                  INC     HL
 3376 FB1D  70                  LD      (HL),B          ;and 'r1'.
 3377 FB1E  23                  INC     HL
 3378 FB1F  77                  LD      (HL),A          ;and lastly 'r2'.
 3379 FB20  C9                  RET     
 3380                   ;
 3381                   ;   This routine select the drive specified in (ACTIVE) and
 3382                   ; update the login vector and bitmap table if this drive was
 3383                   ; not already active.
 3384                   ;
 3385 FB21  2A FCAF     LOGINDRV: LD    HL,(LOGIN)      ;get the login vector.
 3386 FB24  3A F242             LD      A,(ACTIVE)      ;get the default drive.
 3387 FB27  4F                  LD      C,A
 3388 FB28  CD F3EA             CALL    SHIFTR          ;position active bit for this drive
 3389 FB2B  E5                  PUSH    HL              ;into bit 0.
 3390 FB2C  EB                  EX      DE,HL
 3391 FB2D  CD F259             CALL    SELECT          ;select this drive.
 3392 FB30  E1                  POP     HL
 3393 FB31  CC F247             CALL    Z,SLCTERR       ;valid drive?
 3394 FB34  7D                  LD      A,L             ;is this a newly activated drive?
 3395 FB35  1F                  RRA     
 3396 FB36  D8                  RET     C
 3397 FB37  2A FCAF             LD      HL,(LOGIN)      ;yes, update the login vector.
 3398 FB3A  4D                  LD      C,L
 3399 FB3B  44                  LD      B,H
 3400 FB3C  CD F40B             CALL    SETBIT
 3401 FB3F  22 FCAF             LD      (LOGIN),HL      ;and save.
 3402 FB42  C3 F5A3             JP      BITMAP          ;now update the bitmap.
 3403                   ;
 3404                   ;   Function to set the active disk number.
 3405                   ;
 3406 FB45  3A FCD6     SETDSK: LD      A,(EPARAM)      ;get parameter passed and see if this
 3407 FB48  21 F242             LD      HL,ACTIVE       ;represents a change in drives.
 3408 FB4B  BE                  CP      (HL)
 3409 FB4C  C8                  RET     Z
 3410 FB4D  77                  LD      (HL),A          ;yes it does, log it in.
 3411 FB4E  C3 FB21             JP      LOGINDRV
 3412                   ;
 3413                   ;   This is the 'auto disk select' routine. The firsst byte
 3414                   ; of the fcb is examined for a drive specification. If non
 3415                   ; zero then the drive will be selected and loged in.
 3416                   ;
 3417 FB51  3E FF       AUTOSEL:LD      A,0FFH          ;say 'auto-select activated'.
 3418 FB53  32 FCDE             LD      (AUTO),A
 3419 FB56  2A F243             LD      HL,(PARAMS)     ;get drive specified.
 3420 FB59  7E                  LD      A,(HL)
 3421 FB5A  E6 1F               AND     1FH             ;look at lower 5 bits.
 3422 FB5C  3D                  DEC     A               ;adjust for (1=A, 2=B) etc.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  60
BDOS22  Z80

 3423 FB5D  32 FCD6             LD      (EPARAM),A      ;and save for the select routine.
 3424 FB60  FE 1E               CP      1EH             ;check for 'no change' condition.
 3425 FB62  D2 FB75             JP      NC,AUTOSL1      ;yes, don't change.
 3426 FB65  3A F242             LD      A,(ACTIVE)      ;we must change, save currently active
 3427 FB68  32 FCDF             LD      (OLDDRV),A      ;drive.
 3428 FB6B  7E                  LD      A,(HL)          ;and save first byte of fcb also.
 3429 FB6C  32 FCE0             LD      (AUTOFLAG),A    ;this must be non-zero.
 3430 FB6F  E6 E0               AND     0E0H            ;whats this for (bits 6,7 are used for
 3431 FB71  77                  LD      (HL),A          ;something)?
 3432 FB72  CD FB45             CALL    SETDSK          ;select and log in this drive.
 3433 FB75  3A F241     AUTOSL1:LD      A,(USERNO)      ;move user number into fcb.
 3434 FB78  2A F243             LD      HL,(PARAMS)     ;(* upper half of first byte *)
 3435 FB7B  B6                  OR      (HL)
 3436 FB7C  77                  LD      (HL),A
 3437 FB7D  C9                  RET                     ;and return (all done).
 3438                   ;
 3439                   ;   Function to return the current cp/m version number.
 3440                   ;
 3441 FB7E  3E 22       GETVER: LD      A,022H          ;version 2.2
 3442 FB80  C3 F201             JP      SETSTAT
 3443                   ;
 3444                   ;   Function to reset the disk system.
 3445                   ;
 3446 FB83  21 0000     RSTDSK: LD      HL,0            ;clear write protect status and log
 3447 FB86  22 FCAD             LD      (WRTPRT),HL     ;in vector.
 3448 FB89  22 FCAF             LD      (LOGIN),HL
 3449 FB8C  AF                  XOR     A               ;select drive 'A'.
 3450 FB8D  32 F242             LD      (ACTIVE),A
 3451 FB90  21 0080             LD      HL,TBUFF        ;setup default dma address.
 3452 FB93  22 FCB1             LD      (USERDMA),HL
 3453 FB96  CD F4DA             CALL    DEFDMA
 3454 FB99  C3 FB21             JP      LOGINDRV        ;now log in drive 'A'.
 3455                   ;
 3456                   ;   Function to open a specified file.
 3457                   ;
 3458 FB9C  CD F472     OPENFIL:CALL    CLEARS2         ;clear 's2' byte.
 3459 FB9F  CD FB51             CALL    AUTOSEL         ;select proper disk.
 3460 FBA2  C3 F751             JP      OPENIT          ;and open the file.
 3461                   ;
 3462                   ;   Function to close a specified file.
 3463                   ;
 3464 FBA5  CD FB51     CLOSEFIL: CALL  AUTOSEL         ;select proper disk.
 3465 FBA8  C3 F7A2             JP      CLOSEIT         ;and close the file.
 3466                   ;
 3467                   ;   Function to return the first occurence of a specified file
 3468                   ; name. If the first byte of the fcb is '?' then the name will
 3469                   ; not be checked (get the first entry no matter what).
 3470                   ;
 3471 FBAB  0E 00       GETFST: LD      C,0             ;prepare for special search.
 3472 FBAD  EB                  EX      DE,HL
 3473 FBAE  7E                  LD      A,(HL)          ;is first byte a '?'?
 3474 FBAF  FE 3F               CP      '?'
 3475 FBB1  CA FBC2             JP      Z,GETFST1       ;yes, just get very first entry (zero length match).
 3476 FBB4  CD F3A6             CALL    SETEXT          ;get the extension byte from fcb.
 3477 FBB7  7E                  LD      A,(HL)          ;is it '?'? if yes, then we want
 3478 FBB8  FE 3F               CP      '?'             ;an entry with a specific 's2' byte.
 3479 FBBA  C4 F472             CALL    NZ,CLEARS2      ;otherwise, look for a zero 's2' byte.
 3480 FBBD  CD FB51             CALL    AUTOSEL         ;select proper drive.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  61
BDOS22  Z80

 3481 FBC0  0E 0F               LD      C,15            ;compare bytes 0-14 in fcb (12&13 excluded).
 3482 FBC2  CD F618     GETFST1:CALL    FINDFST         ;find an entry and then move it into
 3483 FBC5  C3 F4E9             JP      MOVEDIR         ;the users dma space.
 3484                   ;
 3485                   ;   Function to return the next occurence of a file name.
 3486                   ;
 3487 FBC8  2A FCD9     GETNXT: LD      HL,(SAVEFCB)    ;restore pointers. note that no
 3488 FBCB  22 F243             LD      (PARAMS),HL     ;other dbos calls are allowed.
 3489 FBCE  CD FB51             CALL    AUTOSEL         ;no error will be returned, but the
 3490 FBD1  CD F62D             CALL    FINDNXT         ;results will be wrong.
 3491 FBD4  C3 F4E9             JP      MOVEDIR
 3492                   ;
 3493                   ;   Function to delete a file by name.
 3494                   ;
 3495 FBD7  CD FB51     DELFILE:CALL    AUTOSEL         ;select proper drive.
 3496 FBDA  CD F69C             CALL    ERAFILE         ;erase the file.
 3497 FBDD  C3 F601             JP      STSTATUS        ;set status and return.
 3498                   ;
 3499                   ;   Function to execute a sequential read of the specified
 3500                   ; record number.
 3501                   ;
 3502 FBE0  CD FB51     READSEQ:CALL    AUTOSEL         ;select proper drive then read.
 3503 FBE3  C3 F8BC             JP      RDSEQ
 3504                   ;
 3505                   ;   Function to write the net sequential record.
 3506                   ;
 3507 FBE6  CD FB51     WRTSEQ: CALL    AUTOSEL         ;select proper drive then write.
 3508 FBE9  C3 F8FE             JP      WTSEQ
 3509                   ;
 3510                   ;   Create a file function.
 3511                   ;
 3512 FBEC  CD F472     FCREATE:CALL    CLEARS2         ;clear the 's2' byte on all creates.
 3513 FBEF  CD FB51             CALL    AUTOSEL         ;select proper drive and get the next
 3514 FBF2  C3 F824             JP      GETEMPTY        ;empty directory space.
 3515                   ;
 3516                   ;   Function to rename a file.
 3517                   ;
 3518 FBF5  CD FB51     RENFILE:CALL    AUTOSEL         ;select proper drive and then switch
 3519 FBF8  CD F716             CALL    CHGNAMES        ;file names.
 3520 FBFB  C3 F601             JP      STSTATUS
 3521                   ;
 3522                   ;   Function to return the login vector.
 3523                   ;
 3524 FBFE  2A FCAF     GETLOG: LD      HL,(LOGIN)
 3525 FC01  C3 FC29             JP      GETPRM1
 3526                   ;
 3527                   ;   Function to return the current disk assignment.
 3528                   ;
 3529 FC04  3A F242     GETCRNT:LD      A,(ACTIVE)
 3530 FC07  C3 F201             JP      SETSTAT
 3531                   ;
 3532                   ;   Function to set the dma address.
 3533                   ;
 3534 FC0A  EB          PUTDMA: EX      DE,HL
 3535 FC0B  22 FCB1             LD      (USERDMA),HL    ;save in our space and then get to
 3536 FC0E  C3 F4DA             JP      DEFDMA          ;the bios with this also.
 3537                   ;
 3538                   ;   Function to return the allocation vector.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  62
BDOS22  Z80

 3539                   ;
 3540 FC11  2A FCBF     GETALOC:LD      HL,(ALOCVECT)
 3541 FC14  C3 FC29             JP      GETPRM1
 3542                   ;
 3543                   ;   Function to return the read-only status vector.
 3544                   ;
 3545 FC17  2A FCAD     GETROV: LD      HL,(WRTPRT)
 3546 FC1A  C3 FC29             JP      GETPRM1
 3547                   ;
 3548                   ;   Function to set the file attributes (read-only, system).
 3549                   ;
 3550 FC1D  CD FB51     SETATTR:CALL    AUTOSEL         ;select proper drive then save attributes.
 3551 FC20  CD F73B             CALL    SAVEATTR
 3552 FC23  C3 F601             JP      STSTATUS
 3553                   ;
 3554                   ;   Function to return the address of the disk parameter block
 3555                   ; for the current drive.
 3556                   ;
 3557 FC26  2A FCBB     GETPARM:LD      HL,(DISKPB)
 3558 FC29  22 F245     GETPRM1:LD      (STATUS),HL
 3559 FC2C  C9                  RET     
 3560                   ;
 3561                   ;   Function to get or set the user number. If (E) was (FF)
 3562                   ; then this is a request to return the current user number.
 3563                   ; Else set the user number from (E).
 3564                   ;
 3565 FC2D  3A FCD6     GETUSER:LD      A,(EPARAM)      ;get parameter.
 3566 FC30  FE FF               CP      0FFH            ;get user number?
 3567 FC32  C2 FC3B             JP      NZ,SETUSER
 3568 FC35  3A F241             LD      A,(USERNO)      ;yes, just do it.
 3569 FC38  C3 F201             JP      SETSTAT
 3570 FC3B  E6 1F       SETUSER:AND     1FH             ;no, we should set it instead. keep low
 3571 FC3D  32 F241             LD      (USERNO),A      ;bits (0-4) only.
 3572 FC40  C9                  RET     
 3573                   ;
 3574                   ;   Function to read a random record from a file.
 3575                   ;
 3576 FC41  CD FB51     RDRANDOM: CALL  AUTOSEL         ;select proper drive and read.
 3577 FC44  C3 FA93             JP      READRAN
 3578                   ;
 3579                   ;   Function to compute the file size for random files.
 3580                   ;
 3581 FC47  CD FB51     WTRANDOM: CALL  AUTOSEL         ;select proper drive and write.
 3582 FC4A  C3 FA9C             JP      WRITERAN
 3583                   ;
 3584                   ;   Function to compute the size of a random file.
 3585                   ;
 3586 FC4D  CD FB51     FILESIZE: CALL  AUTOSEL         ;select proper drive and check file length
 3587 FC50  C3 FAD2             JP      RANSIZE
 3588                   ;
 3589                   ;   Function #37. This allows a program to log off any drives.
 3590                   ; On entry, set (DE) to contain a word with bits set for those
 3591                   ; drives that are to be logged off. The log-in vector and the
 3592                   ; write protect vector will be updated. This must be a M/PM
 3593                   ; special function.
 3594                   ;
 3595 FC53  2A F243     LOGOFF: LD      HL,(PARAMS)     ;get drives to log off.
 3596 FC56  7D                  LD      A,L             ;for each bit that is set, we want
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  63
BDOS22  Z80

 3597 FC57  2F                  CPL                     ;to clear that bit in (LOGIN)
 3598 FC58  5F                  LD      E,A             ;and (WRTPRT).
 3599 FC59  7C                  LD      A,H
 3600 FC5A  2F                  CPL     
 3601 FC5B  2A FCAF             LD      HL,(LOGIN)      ;reset the login vector.
 3602 FC5E  A4                  AND     H
 3603 FC5F  57                  LD      D,A
 3604 FC60  7D                  LD      A,L
 3605 FC61  A3                  AND     E
 3606 FC62  5F                  LD      E,A
 3607 FC63  2A FCAD             LD      HL,(WRTPRT)
 3608 FC66  EB                  EX      DE,HL
 3609 FC67  22 FCAF             LD      (LOGIN),HL      ;and save.
 3610 FC6A  7D                  LD      A,L             ;now do the write protect vector.
 3611 FC6B  A3                  AND     E
 3612 FC6C  6F                  LD      L,A
 3613 FC6D  7C                  LD      A,H
 3614 FC6E  A2                  AND     D
 3615 FC6F  67                  LD      H,A
 3616 FC70  22 FCAD             LD      (WRTPRT),HL     ;and save. all done.
 3617 FC73  C9                  RET     
 3618                   ;
 3619                   ;   Get here to return to the user.
 3620                   ;
 3621 FC74  3A FCDE     GOBACK: LD      A,(AUTO)        ;was auto select activated?
 3622 FC77  B7                  OR      A
 3623 FC78  CA FC91             JP      Z,GOBACK1
 3624 FC7B  2A F243             LD      HL,(PARAMS)     ;yes, but was a change made?
 3625 FC7E  36 00               LD      (HL),0          ;(* reset first byte of fcb *)
 3626 FC80  3A FCE0             LD      A,(AUTOFLAG)
 3627 FC83  B7                  OR      A
 3628 FC84  CA FC91             JP      Z,GOBACK1
 3629 FC87  77                  LD      (HL),A          ;yes, reset first byte properly.
 3630 FC88  3A FCDF             LD      A,(OLDDRV)      ;and get the old drive and select it.
 3631 FC8B  32 FCD6             LD      (EPARAM),A
 3632 FC8E  CD FB45             CALL    SETDSK
 3633 FC91  2A F20F     GOBACK1:LD      HL,(USRSTACK)   ;reset the users stack pointer.
 3634 FC94  F9                  LD      SP,HL
 3635 FC95  2A F245             LD      HL,(STATUS)     ;get return status.
 3636 FC98  7D                  LD      A,L             ;force version 1.4 compatability.
 3637 FC99  44                  LD      B,H
 3638 FC9A  C9                  RET                     ;and go back to user.
 3639                   ;
 3640                   ;   Function #40. This is a special entry to do random i/o.
 3641                   ; For the case where we are writing to unused disk space, this
 3642                   ; space will be zeroed out first. This must be a M/PM special
 3643                   ; purpose function, because why would any normal program even
 3644                   ; care about the previous contents of a sector about to be
 3645                   ; written over.
 3646                   ;
 3647 FC9B  CD FB51     WTSPECL:CALL    AUTOSEL         ;select proper drive.
 3648 FC9E  3E 02               LD      A,2             ;use special write mode.
 3649 FCA0  32 FCD5             LD      (MODE),A
 3650 FCA3  0E 00               LD      C,0             ;set write indicator.
 3651 FCA5  CD FA07             CALL    POSITN1         ;position the file.
 3652 FCA8  CC F903             CALL    Z,WTSEQ1        ;and write (if no errors).
 3653 FCAB  C9                  RET     
 3654                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  64
BDOS22  Z80

 3655                   ;**************************************************************
 3656                   ;*
 3657                   ;*     BDOS data storage pool.
 3658                   ;*
 3659                   ;**************************************************************
 3660                   ;
 3661 FCAC  E5          EMPTYFCB:  DB   0E5H            ;empty directory segment indicator.
 3662 FCAD  0000        WRTPRT:  DW     0               ;write protect status for all 16 drives.
 3663 FCAF  0000        LOGIN:   DW     0               ;drive active word (1 bit per drive).
 3664 FCB1  0080        USERDMA: DW     080H            ;user's dma address (defaults to 80h).
 3665                   ;
 3666                   ;   Scratch areas from parameter block.
 3667                   ;
 3668 FCB3  0000        SCRATCH1:  DW   0               ;relative position within dir segment for file (0-3).
 3669 FCB5  0000        SCRATCH2:  DW   0               ;last selected track number.
 3670 FCB7  0000        SCRATCH3:  DW   0               ;last selected sector number.
 3671                   ;
 3672                   ;   Disk storage areas from parameter block.
 3673                   ;
 3674 FCB9  0000        DIRBUF:  DW     0               ;address of directory buffer to use.
 3675 FCBB  0000        DISKPB:  DW     0               ;contains address of disk parameter block.
 3676 FCBD  0000        CHKVECT: DW     0               ;address of check vector.
 3677 FCBF  0000        ALOCVECT:  DW   0               ;address of allocation vector (bit map).
 3678                   ;
 3679                   ;   Parameter block returned from the bios.
 3680                   ;
 3681 FCC1  0000        SECTORS: DW     0               ;sectors per track from bios.
 3682 FCC3  00          BLKSHFT: DB     0               ;block shift.
 3683 FCC4  00          BLKMASK: DB     0               ;block mask.
 3684 FCC5  00          EXTMASK: DB     0               ;extent mask.
 3685 FCC6  0000        DSKSIZE: DW     0               ;disk size from bios (number of blocks-1).
 3686 FCC8  0000        DIRSIZE: DW     0               ;directory size.
 3687 FCCA  0000        ALLOC0:  DW     0               ;storage for first bytes of bit map (dir space used).
 3688 FCCC  0000        ALLOC1:  DW     0
 3689 FCCE  0000        OFFSET:  DW     0               ;first usable track number.
 3690 FCD0  0000        XLATE:   DW     0               ;sector translation table address.
 3691                   ;
 3692                   ;
 3693 FCD2  00          CLOSEFLG:  DB   0               ;close flag (=0ffh is extent written ok).
 3694 FCD3  00          RDWRTFLG:  DB   0               ;read/write flag (0ffh=read, 0=write).
 3695 FCD4  00          FNDSTAT: DB     0               ;filename found status (0=found first entry).
 3696 FCD5  00          MODE:    DB     0               ;I/o mode select (0=random, 1=sequential, 2=special random).
 3697 FCD6  00          EPARAM:  DB     0               ;storage for register (E) on entry to bdos.
 3698 FCD7  00          RELBLOCK:  DB   0               ;relative position within fcb of block number written.
 3699 FCD8  00          COUNTER: DB     0               ;byte counter for directory name searches.
 3700 FCD9  0000  0000  SAVEFCB: DW     0,0             ;save space for address of fcb (for directory searches).
 3701 FCDD  00          BIGDISK: DB     0               ;if =0 then disk is > 256 blocks long.
 3702 FCDE  00          AUTO:    DB     0               ;if non-zero, then auto select activated.
 3703 FCDF  00          OLDDRV:  DB     0               ;on auto select, storage for previous drive.
 3704 FCE0  00          AUTOFLAG:  DB   0               ;if non-zero, then auto select changed drives.
 3705 FCE1  00          SAVNXT:  DB     0               ;storage for next record number to access.
 3706 FCE2  00          SAVEXT:  DB     0               ;storage for extent number of file.
 3707 FCE3  0000        SAVNREC: DW     0               ;storage for number of records in file.
 3708 FCE5  0000        BLKNMBR: DW     0               ;block number (physical sector) used within a file or logical sect
 3709 FCE7  0000        LOGSECT: DW     0               ;starting logical (128 byte) sector of block (physical sector).
 3710 FCE9  00          FCBPOS:  DB     0               ;relative position within buffer for fcb of file of interest.
 3711 FCEA  0000        FILEPOS: DW     0               ;files position within directory (0 to max entries -1).
 3712                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  65
BDOS22  Z80

 3713                   ;   Disk directory buffer checksum bytes. One for each of the
 3714                   ; 16 possible drives.
 3715                   ;
 3716 FCEC  00 00 00 00 CKSUMTBL:  DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 3717                   ;
 3718                   ;   Extra space ?
 3719                   ;
 3720 FCFC  00 00 00 00          DB     0,0,0,0
 3721                   ;
 3722                   ;**************************************************************
 3723                   ;*
 3724                   ;*        B I O S   J U M P   T A B L E
 3725                   ;*
 3726                   ;**************************************************************
 3727                   ;
 3728         FD00      BOOT:    EQU $+0
 3729         FD03      WBOOT:   EQU $+3
 3730         FD06      CONST:   EQU $+6
 3731         FD09      CONIN:   EQU $+9
 3732         FD0C      CONOUT:  EQU $+12
 3733         FD0F      LIST:    EQU $+15
 3734         FD12      PUNCH:   EQU $+18
 3735         FD15      READER:  EQU $+21
 3736         FD18      HOME:    EQU $+24
 3737         FD1B      SELDSK:  EQU $+27
 3738         FD1E      SETTRK:  EQU $+30
 3739         FD21      SETSEC:  EQU $+33
 3740         FD24      SETDMA:  EQU $+36
 3741         FD27      READ:    EQU $+39
 3742         FD2A      WRITE:   EQU $+42
 3743         FD2D      PRSTAT:  EQU $+45
 3744         FD30      SECTRN:  EQU $+48
 3745                   ;
 3746                   ;*
 3747                   ;******************   E N D   O F   C P / M   *****************
 3748                   ;*
 3749                            END
 0 Error(s) Detected.
 5632 Absolute Bytes. 499 Symbols Detected.
